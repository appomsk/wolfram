III. Lists

3.1

Introduction

Lists are the main data structure in Mathematica, and also in functional
programming languages such as LISP. Any complex data structure can be
represented as some (perhaps, complex and nested) list. For example,
N-dimensional array is represented as a list with depth N. Any tree can also
be represented as a list.

Lists can be generated dynamically during the process of program execution,
and the correctly written functions work on lists of arbitrary length without
taking the length of the list as an explicit parameter.  This results in a
quite "clean" code, which is at the same time easy to write. Another advantage
of lists is that it is usually easy to debug functions that work on them - we
will see many examples of these features.  In this chapter we will cover
several built-in functions which are used to generate and process lists.

3.2 The main rule of thumb when working with lists in Mathematica

When we work with lists in Mathematica, especially large ones, it makes sense
to stick to the following main rule: any list we have to treat as a single
unit, and avoid operations that break it into pieces, such as array indexing.
In other words, the best programming style is to try writing the programs such
that the operations are applied to the list as a whole. This approach is
especially important in the functional pro - gramming style, and leads to
significant increase of code efficiency. We will illustrate this issue on many
examples, particularly in the chapter V on functional programming.

3.3 The content of lists

Lists are not required to contain only elements of the same type - they can
contain any Mathematica expressions mixed in an arbitrary way. These
expressions may themselves be lists or more general Mathematica expressions,
of any size and depth. Essentially, a list is a particular case of a general
Mathematica expression, characterized by having the head List:

    In[1]:= Clear[x]; List[Sin[x], Cos[x], Tan[x]]
    Out[1]= {Sin[x], Cos[x], Tan[x]}

3.4 Generation of lists

There are many ways to generate a list

3.4.1 Generating a list by hand

First of all, it is of course possible to generate a list by hand. That is,
some fixed lists in the programs are just defined by the programmer. For
instance:

    n[2]:= Clear[xs, a, b, c, d, e]; xs = {a,b,c,d,e}
    Out[2]= {a, b, c, d, e}

3.4.2 Generation of lists of equidistant numbers by the Range command

In practice it is very often necessary to generate lists of equidistant
numbers. This is especially true in the functional approach since there
functions on such lists replace loops. Such lists can be generated by using
the built-in Range command. Examples:

    In[2]:= Range[5]
    Out[2]= {1, 2, 3, 4, 5}

    In[3]:= Range[2,10]
    Out[3]= {2, 3, 4, 5, 6, 7, 8, 9, 10}

    In[4]:= Range[2,11,3]
    Out[4]= {2, 5, 8, 11}

    In[5]:= Range[0,1,0.1]
    Out[5]= {0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.}

3.4.3 Generation of lists with the Table command

In cases when we need lists of more general nature, often they can be generated by the Table command.
Examples:

    In[6]:= Table[1, {i,1,10}]
    Out[6]= {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

Or simpler:

    In[10]:= Table[1, {10}]
    Out[10]= {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

(* DOES NOT WORK - Table[1,10] - it's possible in Mathematica from some vesion
*)

    n[12]:= Table[i+j+k, {i, 2}, {j, 3}, {k, 2}]
    Out[12]= {{{3, 4}, {4, 5}, {5, 6}}, {{4, 5}, {5, 6}, {6, 7}}}

    In[13]:= Table[i+j+k, {i, 2}, {j, 2}, {k, 2}]
    Out[13]= {{{3, 4}, {4, 5}}, {{4, 5}, {5, 6}}}

    In[14]:= Table[Sin[i], {i, 0, 10, 2}]
    Out[14]= {0, Sin[2], Sin[4], Sin[6], Sin[8], Sin[10]}

As these examples show, Table accepts one or more lists which indicate the
iteration bounds, but we can fill the lists with some functions computed on
the counters being iterated. In cases when we have more than one iterator, we
create a nested list where the innermost iterators correspond to the outermost
lists.  As we see, the bounds of the more outermost iterators may depend on
the variables of more innermost ones, in which case the lists will have
sublists of different lengths. This is where we start seeing that lists are
more general than (multidimensional) arrays since the sublists are not bound
to have the same dimensions. Also, notice that lists created by Table are not
bound to be lists of numbers--they can be lists of functions.

Here, for example, we created a 3x3 matrix of monomials:

    In[16]:= Clear[i,j,x]; Table[x^(i+j), {i,3}, {j,3}]
    Out[15]= {{x ^ 2, x ^ 3, x ^ 4}, {x ^ 3, x ^ 4, x ^ 5}, {x ^ 4, x ^ 5, x ^ 6}}

One more comment about Table is that it is a scoping construct in the sense
that it localizes its iterator variables. It effectively uses Block[] scoping
construct in doing so, with all the consequences which normally accompany the
use of Block[] (see section 4.8). In particular, naively we expect <f[i]>
symbol printed 5 times in the following example, since the definition of <f>
used the global <i>

    n[17]:= Clear[f,i]; f := i^2; Table[f, {i,5}]
    Out[17]= {1, 4, 9, 16, 25}

The global <i> however did not receive any value :

    In[]:= i
    Out[]= i

(* BUG?

The final comment about Table is that while it is a scoping construct, Return[] command can not be used
to break out of it, unlike some other scoping constructs we will encounter:

In[25]:= Table[If[i>3, Return[], i], {i,10}]

*)

3.4.4 A comment on universality of Range

As far as the first and the second examples are concerned, we can get the same result also with the Range
command. Observe:

In[26]:= Range[10]^0
Out[26]= {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}

In[27]:= Range[10]^2
Out[27]= {1, 4, 9, 16, 25, 36, 49, 64, 81, 100}

(* WHAT examples? *)

All other examples can also be done with Range and a small amount of functional programming:

(* BUG in mathicsscript - it treats # as $. But mathics works *)

    In[2]:= Range[3]*# & /@ Range[3]
    Out[2]= {{1, 2, 3}, {2, 4, 6}, {3, 6, 9}}

    In[3]:= Range[#+1, 2*#]& /@ Range[4]
    Out[3]= {{2}, {3, 4}, {4, 5, 6}, {5, 6, 7, 8}}

    In[4]:= Nest[Partition[#, 3, 1]&, Range[3,8], 2]
    Out[4]= {{{3, 4, 5}, {4, 5, 6}, {5, 6, 7}}, {{4, 5, 6}, {5, 6, 7}, {6, 7, 8}}}

    In[5]:= Map[Sin, Range[10]]
    Out[5]= {Sin[1], Sin[2], Sin[3], Sin[4], Sin[5], Sin[6], Sin[7], Sin[8], Sin[9], Sin[10]}

    In[6]:= Clear[x]; x^Range[10]
    Out[6]= {x, x ^ 2, x ^ 3, x ^ 4, x ^ 5, x ^ 6, x ^ 7, x ^ 8, x ^ 9, x ^ 10}

The above examples may look unclear now. We give them here just to show that
one can go a long way with just the Range command, and to clarify the role of
Table. In fact, Table can be thought of as an optimized loop - it is usually
(much) more efficient to create lists with Table rather than to do that in a
loop such as Do, For or While. But in the functional programming, Table is not
so often used, unlike Range, and now you can see why - we can always get the
same effect, and moreover, very often do it faster.

3.4.5 Generation of lists inside loops

3.4.5.1 List generation with Append or Prepend

Such loop generation is possible and resembles most closely what we usually
have in procedural languages. In Mathematica usually this is one of the least
efficient ways to do this. Also, the Table command is actually a loop, but
optimized for list generation and fast. The direct list generation inside a
loop requires the commands Append, Prepend, AppendTo or PrependTo, starting
with an empty list. Append adds one element at the end of the list, and for
reasons which we will explain later is very inefficient in Mathematica for
large lists. Let us instead illustrate this with an example. Here is a simple
list generated with Append:

    In[11]:= For[xs = {}; i=1, i<=5, i++, xs = Append[xs, Sin[i]]]; xs
    Out[11]= {Sin[1], Sin[2], Sin[3], Sin[4], Sin[5]}

This is how we do it with Range:

In[12]:= Sin[Range[5]]
Out[12]= {Sin[1], Sin[2], Sin[3], Sin[4], Sin[5]}


(* SKIP - Just use Timing

3.4.5.2 A digression: <myTiming> : a useful function to measure small execution times
Here I introduce a (user - defined) utility function <myTiming>, which I will use heavily in various
performance measurements throughout the book:

(* doesn't work *)
Clear[myTiming];
myTiming[x_] := Module[{
    z=0, y=0, timelim=0.1, p, q, 
    iterlist=(Power[10,#]& /@ Range[0, 10]),
    nm = If[ToExpression[StringTake[$Version,1]] < 6, 2, 1
    ]},
    Catch[
        If[(z = Nest[First, Timing[(y++; Do[x, {#}]);], nm]) > timelim,
             Throw[{z,y}]
          ] & /@ iterlist] /. {p_, q_} :> p/iterlist[[q]]
];
Attributes[myTiming] = {HoldAll};


The code is a bit involved to explain now, but after reading through the book it may be a good idea to
revisit it, since it illustrates many points. Anyway, for now we are just users.

*)

3.4.5.3 Efficiency pitfall: constructing a list with Append

(* NOTE strawman example but it is really slow *)

Let us compare the elapsed time of such list generation with that of Range,
using the function Timing. Check now:

    In[14]:= Timing[For[xs={}; i=1, i<1000, i++, xs = Append[xs, Sin[i]]];]
    Out[14]= {4.62105, Null}

    In[15]:= Timing[Sin[Range[1000]];]
    Out[15]= {1.03818, Null}

We see that constructing a list of (symbolic) values of Sin on a thousand first natural numbers is hundred
times slower with Append than with Range. But the truth is that the computational complexities are
different and the larger is the list, the more overhead is induced by using Append. We can also see how
Table will perform:

    In[18]:= Table[Sin[i], {i, 1000}]; //Timing
    Out[18]= {1.37619, Null}

(* 

IN Mathematica - {0.000264, Null} - 10_000 times order

In sympy it is very slow too but about 1000 times - 

In [3]: timeit [sin(i) for i in range(1000)]
333 ms ± 666 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

Maxima:

(%i4)	f(x):= makelist(sin(i), i, 1, x);
	timer(f);
        f(1000);
        timer_info(f)

        About 0.01~0.02 secon

*)

We see that it is a little slower than Range.

In addition to being slower, the generation with the loop introduced a global
side effect - the variable <xs>. So, to make the code clean, one will have in
this approach to wrap the loop in an additional modularization construct and
thus make it even clumsier.

So, in conclusion, I would thoroughly discourage the reader from
straightforward list generation inside a loop. First, there are almost always
better design solutions which avoid this problem altogether. Second, there
exist workarounds to get a linear time performance in doing it, such as using
linked lists (to be discussed below), or indexed variables. Finally, starting
with version 5, there are special commands Reap and Sow introduced
specifically for efficient generation and collection of intermediate results
in computa - tions - we will have an entire chapter in the part II devoted to
these commands.

3.5 Internal (full) form of lists

Let me emphasize once again that internal form of lists satisfies the general
requirement of how normal expressions are built in Mathematica (see chapter
I). For example, here are simple and nested lists:

In[6]:= xs = Range[10]; xss = Range /@ Range[5];

And here are their full forms:

In[7]:= FullForm@xs
Out[7]= List[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

In[8]:= FullForm@xss
Out[8]= List[List[1], List[1, 2], List[1, 2, 3], List[1, 2, 3, 4], List[1, 2, 3, 4, 5]]

This shows in particular that list indexing can be performed in the same way
as indexing of more general normal Mathematica expressions, outlined in
chapter I. We will use this fact in the next subsection.

3.6 Working with lists and their parts

3.6.1 List indexing and element extraction with the Part command

3.6.1.1 Simple lists

Consider a simple list:

In[9]:= xs = Range[1, 20, 3]
Out[9]= {1, 4, 7, 10, 13, 16, 19}

Say we need to extract its first element. This is accomplished as follows:

In[10]:= xs[[3]]
Out[10]= 7

Or, which is the same, like this:

In[]:= Part[xs, 3]
Out[]= 7

Now, let us say we need to extract second, fourth and fifth elements. This is how:

> xs[[{2,4,5}]]

Or, which is the same:

> Part[xs, {2,4,5}]

List elements can be also counted from the end of the list. In this case, their positions are negative by
convention:

> xs[[-2]]

3.6.1.2 Working with nested lists

Consider now a more complex list:

> xss = Range[5*#, 5*#+4]& /@ Range[5]

Its elements of level one (we remind that level is the "distance from the
stem", see section 1.1.7) are its sublists:

> xss[[2]]

> xss[[{1,4,5}]]

To get to the numbers, we need in this case a 2-number indexing (since all sublists have a depth 1. Should
they have depth N, we would need N+1 indexes, and should the depth be different for different sublists,
the number of necessary indices would accordingly be different)

> xss[[1,1]]

which means "first element of the first element" (we can view this list as a 2-dimensional array). Notice
that the syntax complextestlist[[{1,1}]] will be interpreted as a twice repeated first element of the original
list, i.e. twice repeated first sublist:

> xss[[{1,1}]]

Everything that was true for simple lists, is also true here:

> xss[[-1]]

> xss[[-1,-1]]

Extract

This operator is analogous to the Part operator, with some extra functionality which is sometimes very
useful but of no interest for us at the moment. What is important now, is that it can extract several elements at different levels at the same time (Part can also extract several elements, but they have to be at the
same level). Also, Extract has a different syntax - to extract an element on the level deeper than the first
(and also, every time when we extract more than one element), the address of the element being extracted
should be entered as a list of indices:

> xs = Range[1,20,3]; xss = Range[5*#, 5*#+4]& /@ Range[5];

(* DOES NOT WORK - the second arg should be LIST 

Extract[xs, 1]

Extract[xss, 1]

*)

> Extract[xs, {1}]

> Extract[xss, {1}]

> Extract[xss, {1,2}]

> Extract[xss, {{1,2}, {3}, {4,5}}]

3.6.3 Take and Drop

These commands are used to take or drop from a list several elements in a row. For example, here are
again our list:

> xs = Range[1,20,3];

And these are examples of how Take and Drop work

> Take[xs, 3]

> Take[xs, {2, 4}]

> Take[xs, -3]

> Take[xs, {-4, -3}]

> Drop[xs, 3]

> Drop[xs, {2, 4}]

> Drop[xs, -3]

> Drop[xs, {-4, -3}]

Both Take and Drop also have some extended functionality to automate structural operations performed
on nested lists, such as extraction of submatrices from matrices. We don’t cover them here, but they are
described in Mathematica Help.

3.6.4 First, Rest, Last and Most

This commands are is in principle redundant, since First[list] is exactly equivalent to list[[1]], Rest[list] is
equivalent to Drop[list,1], Last[list] is equivalent to list[[-1]], and Most[list] is equivalent to Drop[list,-1].
However, they can be used for better code readability.

3.6.5 Length

This command returns the length of the list. For instance:

> xs = Range[1,20,3]; xss = Range[5*#, 5*#+4]& /@ Range[5];

> Length@xs

> Length@xss

If we want to compute the lengths of sublists in <xss>, this can be done as follows:

> Table[Length[xss[[i]]], {i, 1, Length[xss]}]

Here, obviously, the index <i> is used to index the sublists, and thus it runs from 1 to the length of the
main list, while the Part operation [[i]] extracts the sublists.

3.6.6 Modification of list elements by direct indexing (using Part)

3.6.6.1 Simple uses of Part

If it is necessary to replace some element of the list with a known address with some new expression or
value (say, symbol <a>), this can be done directly. Here are our lists:

> xs = Range[1,20,3]; xss = Range[5*#, 5*#+4]& /@ Range[5];

Say, we now want to replace the element with the address <5> with <a>:

> xs[[5]] = a; xss

Now, let us now in our list <xss> replace a random element in every sublist with <a>:

In[25]:= For[i=1, i<=Length[xss], i++,
           xss[[i, RandomInteger[{1,5}]]] = a];
In[26]:= xss
Out[26]= {{5, 6, a, 8, 9}, {10, 11, a, 13, 14}, {15, 16, a, 18, 19}, {20, 21, a, 23, 24}, {25, 26, 27, 28, a}}

Notice that such modifications as described above are only possible if lists are stored in some variable (in
C we would say, that it is an L-value). In particular, this input is a mistake:

In[27]:= Range[10][[3]] = a
Set::setps: Range[10] in the part assignment is not a symbol.
Out[27]= a

Essentially, in all the above examples the Part command ([[ ]] ) was used for modification of expressions.
Note also that the modification of lists with Part introduces side effect, since it is the original variable
where the list is stored that is modified, not the copy of the list.

3.6.6.2 Use Part to efficiently modify large structures

One more thing I would like to mention here is that Part has a very powerful extended functionality which
allows to change many elements at the same time. For example, if I want to change second element in
each sublist of <complextestlist> to <b> and fourth to <c>, I can do this in the following way :

> Part[xss, All, 2] = {b,c,d,e,f}; xss

This turns out to be very handy in cases when many elements have to be changed at once. This is however
limited to cases when these parts form some rather regular structures like sub-matrices etc. For more
details, see Mathematica Help and Mathematica Book, also the description on the web site of Ted Ersek
(see Appendices for the URL).

3.6.7 ReplacePart 

There is another built-in command used to modify list elements - ReplacePart. But there is a big difference
between direct modifications by subscripting (Part) used above, and the functionality of the ReplacePart
command. Notice that as a result of our manipulations with Part, the original lists has been modified.
However, more often in Mathematica programs we would modify a list which is not the original list but a
copy, so that the original list remains unchanged. This style of programming is arguably cleaner but
requires more memory since the original object is copied. Most built-in functions act in this manner. In
particular, this is the case with ReplacePart:

> Clear[a]; xs = Range[1,20,3]

(* DOES NOT WORK - Changed in Mathematica?

> ReplacePart[xs, a, 5]

*)

> ReplacePart[xs, a->5]

But the original list:

> xs

remained unchanged. This also means that ReplacePart does not require L-value to operate on an
expression:

In[37]:= ReplacePart[Range[10], 5->a]
Out[37]= {1, 2, 3, 4, a, 6, 7, 8, 9, 10}

No error in this case - since it did not attempt to change the original list but rather changed the copy of it.

The ReplacePart can be used to change more than a single element at a time, also elements on different
levels of expression. For example:

In[40]:= ReplacePart[Range[10], {2->a, 5->a, 8->a}]
Out[40]= {1, a, 3, 4, a, 6, 7, a, 9, 10}

ReplacePart is described in detail in Mathematica Help.

(* CHECK *) I have to mention however, that ReplacePart can become quite slow
if one wants to change many parts of a large expression at the same time. For
a detailed discussion, please see Appendix C.  Neither do I recommend to use
ReplacePart in such cases by changing elements one by one (say, inside a loop)
rather than all at once. The reason is that since it effectively copies the
entire list and then performs changes on the copy, it will in such a
sequential approach copy the entire list as many times as is the total number
of replacements. This will be terribly inefficient, just as with Append and
Prepend operators. In some of these cases one can efficiently use Part to
change many elements at once - one such example we will consider in chapter VI
(see section 6.5.5.1).

3.6.8 Position

The Position command is used to determine the positions of elements in a list (or more general Mathematica expression) which match a given expression, either exactly, or through patterns.

3.6.8.1 Basic uses of Position

In the simplest form, Position has the following format: Position[list,element] . Let us give a few
examples.  First we initialize our lists:

In[41]:= xs = Range[1,20,3]; xss = Range[5*#, 5*#+4]& /@ Range[5];

We will now use the simplest version of Position (without patterns) to obtain all positions where the
number <4> is found in a list:

In[42]:= Position[xs, 4]
Out[42]= {{2}}

This means that number 4 is the second element in <xs>.

In[43]:= Position[xss, 12]
Out[43]= {{2, 3}}

This means that number 12 is the third element of the second element (sublist) of the list
<xss>.

The Position command can be used together with the Extract command, since they use the same position
specifications:

In[44]:= Extract[xss, Position[xss, 10]]
Out[44]= {10}

3.6.8.2 On less trivial uses of Position

This does not look like a big deal, but we may for example wish to extract the entire sublist containing 10.
All we have to do is to construct a new position list, with the last element (index) dropped:

In[45]:= Map[Most, Position[xss, 10]]
Out[45]= {{2}}

The functionality of Map will be discussed much later, but essentially here it will ensure that if the position
list contains several positions, the last index will be dropped from all of them. For example, here we
define another nested list in which some numbers are found more than once:

In[46]:= yss = Range /@ Range[6]
Out[46]= {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}}

These are all the positions where number 4 is found:

In[47]:= plist = Position[yss, 4]
Out[47]= {{4, 4}, {5, 4}, {6, 4}}

If we use these positions in Extract, we just get number 4 extracted 3 times:

In[48]:= Extract[yss, plist]
Out[48]= {4, 4, 4}

However, if we want to extract all the sublists containing 4, we need one more step. To obtain the posi-
tions of sublists only, we have to delete the last index from each of the sublists in <plist>:

In[49]:= Map[Most, plist]
Out[49]= {{4}, {5}, {6}}

Now we can extract sublists:

In[50]:= Extract[yss, Map[Most, plist]]
Out[50]= {{1, 2, 3, 4}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}}

3.6.8.3 Example: extracting sublists containing given element

Now we will write our first "serious" function: it will extract those sublists from a list, which contain a
given element.

In[51]:= sublistWithElement[xs_List, x_] := Extract[xs, Map[Most, Position[xs, x]]];

For example, these are the sublists of <complextestlist1> which contain number 5:

In[52]:= sublistWithElement[yss, 5]
Out[52]= {{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}}

I used this opportunity to illustrate several common features of user-defined functions in Mathematica.
First, the development of the function: it is usually best to start with some simple test example, develop
the code in steps like above, and then package everything into a function. Second, we saw that the parameters in the function definition on the l.h.s. contain an underscore. This is a sign that patterns are used in the
definition. For now, I will just briefly mention that pattern like <x_> means "any expression" and automati-
cally makes <x> local for the r.h.s., if SetDelayed (:=)was used in the definition (which is normally the
case for functions). The pattern x_h means "anything with the head <h>". Thus, the pattern <main_List>
above will match on any list, but not on a more general expression whose head is not List. This constitutes
a simple type-check.

The other comment about Position function is due here: it is important to remember that while this is an
optimized and fast built-in function, it is still a general-purpose one. In particular, if you have a list sorted
with respect to some criteria, it will be typically much faster for large lists to search for an element with a
version of a binary search, which you can implement in Mathematica (and which has a logarithmic complexity) than with the Position function (which has a linear complexity).

3.6.8.4 More complicated example - sublists with odd number of odd elements

The problem

We will now illustrate the use of Position with patterns on a somewhat less trivial example. Please ignore
the pieces of syntax you are not yet familiar with but rather concentrate on the conceptual part and con-
sider this as an illustration. The problem will be to extract from <yss> all sublists which have
an odd number of odd elements. Our solution will go in steps.

In[46]:= yss = Range /@ Range[6]

Developing a solution

Step1: Find all positions of all odd numbers:

In[53]:= xs1 = Position[yss, _?OddQ]
Out[53]= {{1, 1}, {2, 1}, {3, 1}, {3, 3}, {4, 1}, {4, 3}, {5, 1}, {5, 3}, {5, 5}, {6, 1}, {6, 3}, {6, 5}}

In each of the small sublists, as we already know, the first index gives the number of sublist in
<yss>, and the second one gives the index of the given odd element in this sublist.

Step 2: We combine together the addresses which correspond to the same sublist - they have the same first
element:

In[54]:= xs2 = Split[xs1, First[#1] == First[#2]&]
Out[54]= {{{1, 1}}, {{2, 1}}, {{3, 1}, {3, 3}}, {{4, 1}, {4, 3}}, {{5, 1}, {5, 3}, {5, 5}}, {{6, 1}, {6, 3}, {6, 5}}}

The Split is another built-in command which we will cover shortly and whose purpose is to split a list into
sublists of the "same" elements, where the notion of "same" can be defined by the user. In particular, in
this case we tell Split to consider sublists of indices "same" if they have the same first element. Notice
that now they are combined in extra lists.

Step 3: Leave in the lists only the first elements:

In[55]:= xs3 = Map[First, xs2, {2}]
Out[55]= {{1}, {2}, {3, 3}, {4, 4}, {5, 5, 5}, {6, 6, 6}}

Step4: In the above lists, leave only the sublists with odd length (the length of these sublists corresponds to
the number of odd elements in the sublists of our original list, with addresses equal to numbers repeated in
the sublists above).

In[56]:= xs4 = Cases[xs3, x_List /; OddQ[Length[x]]]
Out[56]= {{1}, {2}, {5, 5, 5}, {6, 6, 6}}

<Cases> is the command used to find the list of all occurrences of some expression or pattern in a larger
expression. We will cover it later.

Step5: Replace all sublists by their first elements:

In[57]:= xs5 = Union@Flatten@xs4
Out[57]= {1, 2, 5, 6}

<Flatten> makes any list flat, and <Union> removes duplicate elements and sorts the resulting list.

Step 6: Extracting the sublists:

In[58]:= yss[[xs5]]
Out[58]= {{1}, {1, 2}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}}

Assembling the code into a function

We can write all the steps into a single function:

(* MY *)

oddSublist[xss_List] := Module[
   {t},
   t = Position[xss, _?OddQ];
   t = Split[t, First[#1] == First[#2]&];
   t = Map[First, t, {2}];
   t = Cases[t, x_List /; OddQ[Length[x]]];
   t = Union[Flatten[t]];
   xss[[t]]
]
    
Check:

In[4]:= oddSublist[yss]
Out[4]= {{1}, {1, 2}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}}

An alternative functional implementation

There is a much simpler but less obvious way to do the same thing by using the mixed rule-based and
functional programming style. I will give here the code just for an illustration:

In[8]:= oddSublistNew[xss_List] := Map[If[EvenQ[Count[#, _?OddQ]], # /. #->Sequence[],#]&, xss];

Check:

In[9]:= oddSublistNew[yss]
Out[9]= {{1}, {1, 2}, {1, 2, 3, 4, 5}, {1, 2, 3, 4, 5, 6}} 

While the first realization became significantly complex to question the advantage of this programming
style compared to a traditional procedural programming based on nested loops, my primary goal here was
to illustrate the use of Position command, and perhaps give a flavor of a few others.

However, the second realization is clearly shorter. This kind of programs can be written very quickly and
are typically very short.

A procedural version

It is also less bug-prone than the possible procedural implementation based on 2 nested loops:

In[]:= oddSublistProc[xss_List] := Module[{pos = {}, ctr, i, j},
          For[i = 1, i <= Length[xss], i++,
              For[j = 1; ctr = 0, j <= Length[xss[[i]]], j++,
              If[OddQ[xss[[i, j]]], ctr++];];
              If[OddQ[ctr], AppendTo[pos, i]];];
          Return[xss[[pos]]]];

Check:

> oddSublistsProc@yss 

Apart from being clumsier, this code also uses AppendTo to append elements to a list, which will make it
inefficient for large lists, just as in the examples we considered before.

3.7 Adding elements to the list and removing them from the list

3.7.1 Append, Prepend, AppendTo and PrependTo

Some of these commands we have already encountered before. They add an element to the end or to the
beginning of the list. For example:

> Clear[a]; xs = Range[5];

> Append[xs, a]

> Prepend[xs, a]

> xss

The last output shows that the list <xs> did not change. As we discussed, the absence of side-effects is
typical for Mathematica built-in functions. In this case, Append and Prepend
forged a copy of <xs>
and modified this copy. If we want an original list to be modified, we have either to write:

> xs = Append[xs, a];

> xs

or, which is equivalent, to use the function AppendTo, which does exactly this:

> xs = Range[5];

> AppendTo[xs, a];

> xs

The situation with Prepend and PrependTo is completely analogous. And also, recalling the previous
discussions, we may suspect that the application of AppendTo or PrependTo to a list which is not assigned
to any variable (not an L-value) is a mistake, and we will be correct:

> Append[Range[5], a]

In[13]:= AppendTo[Range[5], a]
AppendTo::rvalue: Range[5] is not a variable with a value, so its value cannot be changed.

As we already discussed, it is best to avoid using these functions (Append etc) for modifying large lists.
Later we will consider several more efficient alternatives.

3.7.2 Insert and Delete

As is clear from their names, these functions are used to insert an element to or delete it from the list, or
more general Mathematica expression. These operations are well described in Mathematica Help. We
will give just a few examples of their use. The format of Insert is Insert[list,new,pos] - this will insert the
new element <new> in the position <pos> in the list <list>. Delete has a similar syntax Delete[list,pos]
and respectively deletes from the list <list> an element at position <pos>. For example:


> xs = Range[3, 15, 2]

> Delete[xs, 4]

> Insert[xs, a, 5]

Notice that once again, both of these commands work on the copy of the original list that they create, so
that the original list remains unchanged:

> xs

Both of these commands can work on nested lists (or more general expressions), and then the position will
be a list of indexes. Also, they may also receive a list of positions rather than a single position - in this
case, an element will be inserted or deleted in many places at once.

However, in the case of Insert, it may become quite slow if a large number of parts have to be inserted at
the same time. For a more detailed discussion, please see the Appendix C.

3.8 Working with nested lists

It is often necessary to work with nested lists, that is - lists whose elements themselves are lists. We have
seen simple examples of such lists already. Let me emphasize that in general such lists are not identical to
multidimensional arrays but in fact much more general, because the lengths of sublists at each level can be
different. The only thing we can say about the general nested list is that it represents some tree.
Here we will consider several special-purpose commands which were designed for efficient processing of
some special types of such nested lists.

3.8.1 Partition

This command is used to "cut" or "slice" some list into (possibly overlapping) pieces. In its simplest form,
it has a format Partition[list, size, shift]. It cuts the list into pieces with the length <size>, and shifted one
with respect to another by <shift>. If the <shift> parameter is not given, the list is cut into non-overlapping
pieces. For example:

3.8.1.1 A simple example

In[16]:= xs = Table[Sqrt[i], {i, 1, 10}]
Out[16]= {1, Sqrt[2], Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7], 2 Sqrt[2], 3, Sqrt[10]}

In[17]:= Partition[xs, 3]
Out[17]= {{1, Sqrt[2], Sqrt[3]}, {2, Sqrt[5], Sqrt[6]}, {Sqrt[7], 2 Sqrt[2], 3}}

In[18]:= Partition[xs, 7]
Out[18]= {{1, Sqrt[2], Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7]}}

In the last example, the remaining piece had a size smaller than 7, so it was "eaten up". Now we will
partition with overlaps:

> Partition[xs, 7, 1]

3.8.1.2 An example of practical use: computation of the moving average in a list.

This example is based on a similar discussion in Wagner’96.

The problem

The m-moving average for a list is an average which is obtained by averaging every element in a list with
<m> neighbors to the right and to the left (which means that this quantity is only defined for points
(elements) having at least m neighbours both to the left and to the right). Thus, moving average is actually
a list of such averages, of the length <len>-2m, where <len> is a length of an initial list.78
The m-moving average for a list is an average which is obtained by averaging every element in a list with
<m> neighbors to the right and to the left (which means that this quantity is only defined for points
(elements) having at least m neighbors both to the left and to the right). Thus, moving average is actually
a list of such averages, of the length <len>-2m, where <len> is a length of an initial list.

Developing a solution

To solve our problem, we will first define an auxiliary function which will
count the average of a list of numbers. However, it will turn out that our
function will also work on a list of lists of numbers, this time summing
entire lists (with the same number of elements) together, which we will use.
So:

In[24]:= listAverage[xs_List] := Total[xs]/Length[xs];
In[25]:= listAverage[Range[10]]
Out[25]= 11 / 2

Now we will define another auxiliary function:

In[26]:= neigborLists[xs_List, n_Integer] := Partition[xs, Length[xs]-2*n,1]

For example:

In[27]:= neigborLists[xs,1]
Out[27]= {{1, Sqrt[2], Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7], 2 Sqrt[2]}, {Sqrt[2], Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7], 2 Sqrt[2], 3}, {Sqrt[3], 2, Sqrt[5], Sqrt[6], Sqrt[7], 2 Sqrt[2], 3, Sqrt[10]}}

Let us now realize that the middle list represents a list of "middle points", and the first and the last list
represent here lists of closest "neighbors" for these middle points. Thus, the only thing left to do is to use
listAverage on this result:

> listAverage[neighborLists[xs, 1]]

Packaging code to a function

Thus, our final function <movingAverage>will look like:

Clear@movingAverage, neighborLists, listAverageD;
neighborLists@x_List, m_IntegerD :=
Partition@x, Length@xD -2 * m, 1D;
listAverage@x_ListD := Apply@Plus, xD  Length@xD;
movingAverage@x_List, m_IntegerD :=
listAverage@neighborLists@x, mDD;
For example, here we find the moving average with two neighbors on each side:

In[30]:= movingAverage[xs_List, n_Integer] := listAverage[neigborLists[xs, n]]
In[31]:= movingAverage[xs, 2]

Using functional programming to eliminate auxiliary functions

With the help of the functional programming syntax, we can write this as a single function and eliminate
the need in auxiliary functions altogether:

In[34]:= movingAverage[xs_List, n_Integer] := (Plus @@ #) / Length[#]& @ Partition[xs, Length[xs]-2*n, 1]
In[35]:= movingAverage[xs,2]

A procedural version

Here is the procedural implementation of the same thing:

In[36]:= movingAverage[xs_List, n_Integer] := Module[
           {i, j, ln = Length[xs], aver, sum},
           aver = Table[0, {ln - 2*n}];
           For[i = n + 1, i <= ln - n, i++,
            sum = 0;
            For[j = i - n, j <= i + n, j++,
             sum = sum + xs[[j]]];
            aver[[i - n]] = sum/(2*n + 1)];
           aver]
           
Efficiency comparison

(* MY Again... Let's compare Python numpy code with something like
lambda i: () if i==0 else (i,) + makecons(i-1) (1000) *)

The problem with the procedural version is not just that the code is longer, but also that it is more error
prone (array bounds, initialization of variables etc). On top of that, it turns out to be far less efficient. Let
us compare the efficiency on large lists:

(* MY Not bad with 0.016 from the book *)

In[41]:= Timing[movingAverage[Range[1000],10];]
Out[41]= {0.886224, Null}

(* MY Hm... Why so slow in comapison with the functional version? 
I do not understand the code *)

In[42]:= Timing[movingAverageProc[Range[1000],10];]
Out[42]= {57.6071, Null}

Here we have a 100 times difference (for this length of the list)! And
moreover, this is not a constant factor, but the difference will increase
further with the length of the list. Of course, in procedural languages such
as C the latter implementation is natural and fast. Not so in Mathematica.
However, one can still obtain the code which will be concise, fast and elegant
at the same time, with the use of functional programming methods.

3.8.2 Transpose

This is one of the most useful commands. It has this name since for matrices,
which are represented as 2- dimensional lists of lists, it performs the
transposition operation. However, we are not forced to always interpret the
two-dimensional array as a matrix, especially if it is combined from elements
of different types. Then it turns out that the number of useful things one can
do with Transpose is much larger. But let us start with the numeric lists: say
we have a given list of lists of some elements (they may be lists themselves,
but this does not matter for us):

3.8.2.1 Simple example: transposing a simple matrix

In[43]:= xs = Table[i+j, {i, 2}, {j, 3}];

Then,

In[44]:= Transpose@xs
Out[44]= {{2, 3}, {3, 4}, {4, 5}}

3.8.2.2 Example: transposing a matrix of lists

Another example:

In[45]:= xs = Table[{i,j}, {i, 2}, {j, 3}]

This is a 2-dimensional array of lists.

In[46]:= Transpose@xs
Out[46]= Transpose[{{{1, 1}, {1, 2}, {1, 3}}, {{2, 1}, {2, 2}, {2, 3}}}]

3.8.2.3

Example: combining names with grades

Another example: we have results of some exam - the scores - as a first list, and last names of the students
as another one. We want to make a single list of entries like {{student1,score1},...}.


> names = {"Smith", "Johnson", "Peterson"};
> scores = {70, 90, 50};

Then we do this:

> Transpose[{names, scores}]

But we will get most out of Transpose when we get to functional programming, since Transpose is very
frequently used there for efficient structure rearrangements. We will see many examples of its use in the
chapters that follow.

3.8.3 Flatten

This command is used to destroy the structure of nested lists, since it removes all internal curly braces and
transforms any complicated nested list into a flat one. For example:

3.8.3.1 Simple example: flattening a nested list

> xs = Table[{i, j}, {i, 2}, {j, 3}]

> Flatten@xs

3.8.3.2 Flattening down to a given level

One can make Flatten more "merciful" and selective by instructing it to destroy only braces up to (or,
more precisely, down to) a certain level in an expression. The level up to which the "destruction" has to be
performed is given to Flatten as an optional second parameter. For instance:

> Flatten[xs, 1]

Example: flattening a nested list level by level

Another example:

> xs = Table[{i, j, k}, {i, 2}, {j, 2}, {k, 3}]

> Flatten[xs, 1]

> Flatten[xs, 2]

> Flatten[xs, 3]

In practice, most frequently one uses either Flatten[expr] to get a completely flat list, or Flatten[expr,1]
to remove some internal curly braces which were needed at some intermediate steps but not anymore.

3.8.3.3 Application: a computation of quadratic norm of a tensor of arbitrary rank (vector, matrix
etc).

The problem and the solution

Here we will show how the use of Flatten can dramatically simplify the computation of the norm of a
tensor of arbitrary rank. What may be surprising is that we will not need the rank of the tensor as a sepa -
rate parameter. So, we wil start with the code:

In[47]:= tensorNorm[xs_List] := Sqrt[Plus@@Flatten[x^2]]

It turns out that this tiny code is all what is needed to solve the problem in all generality.

Code dissection

Let us use an example to show how it works. This will be our test matrix:

In[48]:= mat = Table[i+j, {i, 3}, {j, 3}]
Out[48]= {{2, 3, 4}, {3, 4, 5}, {4, 5, 6}}

The norm is the square root of sum of the squares of all matrix elements.
First, we will use the fact that arithmetic operations such as raising to some
power, can be used on entire lists, because they are automati- cally threaded
over the elements of the list (functions which have this property are said to
be Listable).  Thus, we first square all the elements:

n[49]:= mat^2
Out[49]= {{4, 9, 16}, {9, 16, 25}, {16, 25, 36}}

Since we don’t care which elements are where but just need to sum them all, we
will use Flatten to remove the internal curly braces:

In[3]:= Flatten[mat^2]
Out[3]= {4, 9, 16, 9, 16, 25, 16, 25, 36}

Now we have to some all the elements, and as we saw already this can be done for instance with Plus@@
construction:

In[8]:= Total@Flatten@(mat^2)
Out[8]= 156

Finally, we have to take a square root:

> Sqrt@Total@Flatten@(mat^2)

And we arrive at the code of our function. We see that the function works well
on a tensor of any rank without modifications! It would be hard to do this
without Flatten, and in particular, in languages like C we would need nested
loops to accomplish this (in C, there is also a technique called flattening an
array, which consists in exploiting the row-major order in which it is stored
in memory and going through the multidimensional array with just a pointer to
an integer (or whatever is the type of the smallest array element). Although
it usually works, it will be illegal if one wants to strictly adhere to the C
standard).

3.8.3.4 Application - (relatively) fast list generation with Flatten

As we already mentioned, generating lists straightforwardly in loops is perhaps the worst way to do it, in
terms of efficiency. One can use Flatten to speed-up this process considerable. Say, we want to generate a
list from 1 to 10 (which is easiest to do, of course, by just using Range[10]). We can do it in the following
fashion:

Step 1. We generate a nested list (this type of lists are also called linked lists in Mathematica):

In[14]:= For[xs={}; i=1, i<=10, i++, xs = {xs, i}]; xs
Out[14]= {{{{{{{{{{{}, 1}, 2}, 3}, 4}, 5}, 6}, 7}, 8}, 9}, 10}

Step 2. We use Flatten:

> Flatten@xs

Let us compare the execution time with the realization with Append described previously:

In[26]:= For[xs={}; i=1, i<=1000, i++, AppendTo[xs, i]]; // Timing
Out[26]= {1.72302, Null}

Now, with our new method:

In[27]:= For[xs={}; i=1, i<=1000, i++, xs = {xs, i}] // Timing
Out[27]= {1.04324, Null}

(* NOT We see that the difference is about an order of magnitude at least. While even this method by itself is not
the most efficient, we will later see how linked lists can be used in certain problems to dramatically
improve efficiency. *)

3.9 Working with several lists

It is often necessary to obtain unions, intersections, and complements of two or more lists, and also to
remove duplicate elements from a list. This is done by such built-in commands as Join, Intersection,
Complement and Union.

3.9.1 The Join command

The Join command joins together two or several lists. The format of it is Join[list1,...,listn], where
<list1,..., listn> are lists, not necessarily of the same depth or structure. If the lists contain identical elements, the elements are not deleted - i.e., the lists are joined together as is, with no further modification of
their internal structure. Examples:

> Clear[a, b, c, d, e, f];

> Join[{a, b, c}, {d, e, f}]

> Join[{{a, b}, {c, d}}, {e, f}]

Join connects lists together from left to right, as they are, without any
sorting or permuting the elements.

3.9.2 The Intersection command

The Intersection command finds the intersection of two or more lists, that is a set of all elements which
belong to all of the intersected lists. The format of the command : Intersection[list1, ..., listn]. Examples:

> Intersection[{a, b, c}, {b, c, d, e}]

> Intersection[{a, b, c, d, e, f}, {a, b, c}, {c, d, e}]

> Intersection[{a, b, c}, {d, e, f}]

In the latter case we got an empty list, because the intersection of the latter two lists is empty.
The Intersection command has an option SameTest which can be used to provide a custom "sameness"
function - this way we can define our notion of "same" different from the default one. Please see the
Union command for an example of use of this option. Also, with this option, Intersection may be slower or
much slower than in its "pure" form. For a more detailed discussion, please see Appendix C.

3.9.3 The Complement command

The command Complement[listAll,list1,...,listn] gives a complement of the list <listAll> with respect to
the union of all other lists <list1,...,listn>. In other words, it returns all the elements of <listAll> which are
not in any of <listk>. Note that Complement sorts the resulting list. Examples:

> Complement[{a, b, c, d, e, f}, {b, c, e}]
> 
> Complement[{a, b, c, d, e, f}, {b, c, e}, {d, e, f}]
> 
> Complement[{a, b, c, d, e, f}, {b, c, e}, {d, e, f}, {a, b, c}]

The Complement command, like Intersection, has the option SameTest, which
allows us to define our own notion of "sameness" of objects. All the comments
I made for Intersection with this option, also apply here.

3.10 Functions related to list sorting

Here we will discuss three very useful built-in functions related to list sorting. Sort function sorts the list.
Union function removes duplicate elements from the list and also sorts the result. Split function splits the
list into sublists of same adjacent elements. For all three functions, one can define the notion of
"sameness" different from the default one. Below we give more details and examples of use for every of
these functions.

3.10.1 The Sort command

3.10.1.1 Basic Sort

This function is used for list sorting. For example :

> Clear[a, b, c, d, e, f, g, t];

> Sort[{a, d, e, b, g, t, f, d, a, b, f, c}]

> Sort[{5, 7, 2, 4, 3, 1}]

Sort will sort a list of arbitrary Mathematica expressions. By default, the
sorting is performed lexicographically for symbols, in ascending order for
numbers, by the first elements for lists. In general, this is called a
canonical sorting order in Mathematica - consult Mathematica Help for more
information.

For example, here we will sort a nested list of integers:

In[33]:= nested = Table[RandomInteger[15], {5}, {RandomInteger[{3,10}]}]

In[34]:= Sort@nested

We see that the sorting is performed by the first element of the sublists.

3.10.1.2 Sort with a user-defined sorting function

As an optional second argument, Sort accepts the comparison function to be used instead of the default
one. For example:

In[35]:= Sort[{5,6,2,3,4,1}, Greater]
Out[35]= {6, 5, 4, 3, 2, 1}

We can for instance sort our nested list by the length of a sublist. We first define a sorting function:

In[36]:= sortFunction[x, y] := Length[x] < Length[y]

And now sort:

In[37]:= Sort[nested, sortFunction]

3.10.1.3 A first look at pure functions

Mathematica provides a mechanism to construct and use functions without giving them names or separate definitions, the so called "pure functions" (they are called lambda functions in some other languages).
We will cover them systematically later, but this is how the previous sorting would look should we use a
pure function:

> Sort[nested, Length[#1] < Length[#2]&]

Any function of two variables which always returns True or False, can be a sorting function. It is assumed
that it gives True or False depending on which element is considered "larger".

I have to mention also that using Sort with a user - defined sorting function may considerably slow down
the Sort function. For a more detailed discussion, please see Appendix C.

(* NO such command in Mathics 

3.10.1.4 The Ordering command

This command gives a permutation of indices needed to sort an input list. It also exists in both "pure" form
and with a user - defined comparison function. It gives more information than just Sort, but in particular
one can also sort a list using a combination of Ordering and Part.88

For example, here is a list we considered before :

> listtosort = {a, d, e, b, g, t, f, d, a, b, f, c}

> Ordering@listtosort

Ordering is a very useful command, exactly because it provides more information than just Sort, while
being as efficient as Sort itself. We will see an example of its use in chapter VI.

*)

3.10.2 The Union command

The command Union[list] returns a canonically sorted list of all distinct elements of <list> .

3.10.2.1 Basic Union

In its basic form, Union takes a list as a single argument, and returns sorted unique elements in a list. The
sorting is done by a default sorting function in Mathematica (this is lexicographic for symbolic expressions, in increasing order for numeric ones, by first element for lists etc). Examples :

> Union@{a, d, e, b, g, t, f, d, a, b, f, c}

In[43]:= xs = Table[RandomInteger[10], {15}]
Out[43]= {10, 2, 5, 8, 5, 3, 3, 3, 9, 3, 6, 7, 5, 9, 10}

In[44]:= Union@xs
Out[44]= {2, 3, 5, 6, 7, 8, 9, 10}

The fact that the Union command sorts the resulting list, is intrinsically related with the algorithm that
Union uses. If the elements should not be sorted, one can write a custom union function (we will consider
a couple of implementations later, see section 5.2.6.2.5), which however will certainly be slower than the
built-in Union.

3.10.2.2 Union with the SameTest option

The Union command has an option SameTest, which allows us to give it our own definition of which
elements have to be considered same. For example, we may consider elements the same if they are the
same modulo 3:

In[45]:= Union[xs, SameTest -> (Mod[#1-#2, 3] == 0&)]
Out[45]= {2, 3, 10}

Union@testlist, SameTest ® HMod@ð1 -ð2, 3D  0 &LD
81, 2, 3<
It should be noted that Union with the SameTest function may perform slower or much slower than the
"pure" Union. For more details and discussion, please see the Appendix C.89
It should be noted that Union with the SameTest function may perform slower or much slower than the
"pure" Union. For more details and discussion, please see the Appendix C.
 3.10.3
The Split command
This command is used to split the list into several sublists, so that elements in each sublist are the same.
This function can accept the "sameness" function as an optional second argument. It goes through the list
and compares adjacent elements, using either the default sameness function, which is SameQ, or the
sameness function provided to it. Whenever two adjacent elements are not the same, it groups the just
passed group of same elements in a sublist and starts a new sublist.
 3.10.3.1
Basic Split
In its basic form, Split takes a list to split, as a single argument, and uses the SameQ predicate for element
comparison. For example, here we introduce a list and its sorted version:
testlist = Table@Random@Integer, 81, 15<D, 820<D
sorted = Sort@testlistD
88, 12, 10, 3, 13, 15, 13, 6, 6, 2, 4, 9, 5, 11, 6, 10, 7, 4, 15, 5<
82, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 9, 10, 10, 11, 12, 13, 13, 15, 15<
Because in general the adjacent elements in an unsorted list are different, we see that most sublists here
will contain a single element:
Split@testlistD
888<, 812<, 810<, 83<, 813<, 815<, 813<, 86, 6<,
82<, 84<, 89<, 85<, 811<, 86<, 810<, 87<, 84<, 815<, 85<<
Not so for a sorted list:
Split@sortedD
882<, 83<, 84, 4<, 85, 5<, 86, 6, 6<, 87<,
88<, 89<, 810, 10<, 811<, 812<, 813, 13<, 815, 15<<
 3.10.3.2
Split with a user-defined sameness function
We can now define two elements the same if, for example, they have the same remainder under the divi-
sion by 3. However, before using Split to group such elements together, we will have to sort the list with a
different sorting function, so that elements which are the same modulo 3 will be adjacent to each other in a
sorted list:
mod3sorted = Sort@testlist, Mod@ð1, 3D <Mod@ð2, 3D &D
815, 6, 9, 6, 6, 15, 3, 12, 4, 7, 10, 4, 13, 13, 10, 5, 11, 5, 2, 8<
Now we can split this list:
Split@mod3sorted, Mod@ð1, 3D  Mod@ð2, 3D &D
8815, 6, 9, 6, 6, 15, 3, 12<, 84, 7, 10, 4, 13, 13, 10<, 85, 11, 5, 2, 8<<
Split is a very useful function. Since it performs a single run through the list and only compares adjacent
elements, its complexity is linear. Also, because the number of comparisons is equal to the length of the
list (minus one), it does not suffer so severely from the performance penalties associated with the use of
user-defined sameness functions, which we discussed for the Sort and Union functions.90
Split is a very useful function. Since it performs a single run through the list and only compares adjacent
elements, its complexity is linear. Also, because the number of comparisons is equal to the length of the
list (minus one), it does not suffer so severely from the performance penalties associated with the use of
user-defined sameness functions, which we discussed for the Sort and Union functions.
 3.10.3.3
Example: run-length encoding
One standard application of Split is a run-length encoding. Given a list of possibly repetitive numbers, this
encoding consists of replacing this list with a list of elements like {{num1,freq1},...}, where <freqk> gives
the total number of consecutive copies of <numk>. For instance, take the result of our first example: all
we need to do is to change each sublist to the form just described, which can be done for example like this:
Clear@runEncodeSplitD;
runEncodeSplit@spl_ListD :=
Table@8spl@@i, 1DD, Length@spl@@iDDD<, 8i, Length@splD<D;
Clear@runEncodeD;
runEncode@x_ListD := runEncodeSplit@Split@xDD;
Check:
runEncode@sortedD
882, 1<, 83, 2<, 84, 3<, 85, 1<, 86, 2<,
88, 2<, 89, 1<, 811, 4<, 812, 2<, 814, 1<, 815, 1<<
With the functional programming, we can eliminate the need of an auxiliary function runEncodeSplit:
Clear@runEncodeFPD;
runEncodeFP@x_ListD := Map@8First@ðD, Length@ðD<&, Split@xDD;
Check:
runEncodeFP@testlistD
881, 1<, 82, 3<, 83, 1<, 84, 2<,
88, 3<, 89, 3<, 810, 4<, 813, 1<, 815, 2<<
 3.10.3.4
Example: computing frequencies of identical list elements
As another related application of Split, we will use it in conjunction with Sort to implement a function
which will count frequencies of the identical elements in a list. This is extremely easy to do if we notice
that we just have to Sort the original list and the use the <runEncode> function on a sorted list:
Clear@frequenciesD;
frequencies@x_ListD := runEncode@Sort@xDD;
Check:
frequencies@testlistD
882, 1<, 83, 2<, 84, 3<, 85, 1<, 86, 2<,
88, 2<, 89, 1<, 811, 4<, 812, 2<, 814, 1<, 815, 1<<
In fact, in essentially the same way the function Frequencies is implemented in the ‘Statistics‘DataManip-
ulation add-on package.91
In fact, in essentially the same way the function Frequencies is implemented in the ‘Statistics‘DataManip-
ulation add-on package.
There are many other situations where Split is quite useful - we will give further examples of its use in the
subsequent chapters.
Clear@testlist, sorted, mod3sorted, listDivide,
frequencies, runEncodeSplit, runEncode, runEncodeFPD;
Summary
In this chapter we introduced lists - the main building blocks of data structures in Mathematica. We
considered various operations on lists such as list generation, element extraction, addition, replacement
and deletion, locating elements with certain properties in the list, and also several specialized commands
for fast structural operations on one or several lists, as well as those related to sorting of lists. The follow-
ing built-in functions were considered in detail: Range,Table,Part, Extract, Take, Drop, First, Rest, Most,
Last, Position, Length, Append, Prepend, AppendTo, PrependTo, Partition, Transpose, Flatten, Join,
Union, Intersection, Complement, Sort, Split.
Armed with these functions, we can already go a long way in solving various problems. However, we
need another major component for serious program building - an understanding of functions in Mathemat-
ica: what they are, how to define them, etc. This is a topic of the next chapter.
