III. Lists
3.1
Introduction
Lists are the main data structure in Mathematica, and also in functional programming languages such as
LISP. Any complex data structure can be represented as some (perhaps, complex and nested) list. For
example, N-dimensional array is represented as a list with depth N. Any tree can also be represented as a
list.
Lists can be generated dynamically during the process of program execution, and the correctly written
functions work on lists of arbitrary length without taking the length of the list as an explicit parameter.
This results in a quite "clean" code, which is at the same time easy to write. Another advantage of lists is
that it is usually easy to debug functions that work on them - we will see many examples of these features.
In this chapter we will cover several built-in functions which are used to generate and process lists.
3.2
The main rule of thumb when working with lists in Mathematica
When we work with lists in Mathematica, especially large ones, it makes sense to stick to the following
main rule: any list we have to treat as a single unit, and avoid operations that break it into pieces, such as
array indexing. In other words, the best programming style is to try writing the programs such that the
operations are applied to the list as a whole. This approach is especially important in the functional pro -
gramming style, and leads to significant increase of code efficiency. We will illustrate this issue on many
examples, particularly in the chapter V on functional programming.
3.3
The content of lists
Lists are not required to contain only elements of the same type - they can contain any Mathematica
expressions mixed in an arbitrary way. These expressions may themselves be lists or more general Mathe-
matica expressions, of any size and depth. Essentially, a list is a particular case of a general Mathematica
expression, characterized by having the head List:
Clear@xD;
List@Sin@xD, Cos@xD, Tan@xDD
8Sin@xD, Cos@xD, Tan@xD<
3.4
Generation of lists
There are many ways to generate a list
 3.4.1
Generating a list by hand
First of all, it is of course possible to generate a list by hand. That is, some fixed lists in the programs are
just defined by the programmer. For instance:59
Clear@testlist, a, b, c, d, eD;
testlist = 8a, b, c, d, e<
Clear@testlistD;
8a, b, c, d, e<
 3.4.2
Generation of lists of equidistant numbers by the Range command
In practice it is very often necessary to generate lists of equidistant numbers. This is especially true in the
functional approach since there functions on such lists replace loops. Such lists can be generated by using
the built-in Range command. Examples:
Range@5D
Range@2, 10D
Range@2, 11, 3D
Range@0, 1, 0.1D
81, 2, 3, 4, 5<
82, 3, 4, 5, 6, 7, 8, 9, 10<
82, 5, 8, 11<
80, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.<
 3.4.3
Generation of lists with the Table command
In cases when we need lists of more general nature, often they can be generated by the Table command.
Examples:
Table@1, 8i, 1, 10<D
Table@i ^ 2, 8i, 1, 10<D
Table@i * j, 8i, 1, 3<, 8j, 1, 3<D
Table@i +j, 8i, 1, 4<, 8j, 1, i<D
Table@i +j +k, 8i, 1, 2<, 8j, 1, 3<, 8k, 1, 3<D
Table@Sin@iD, 8i, 1, 10<D
81, 1, 1, 1, 1, 1, 1, 1, 1, 1<
81, 4, 9, 16, 25, 36, 49, 64, 81, 100<
881, 2, 3<, 82, 4, 6<, 83, 6, 9<<
882<, 83, 4<, 84, 5, 6<, 85, 6, 7, 8<<
8883, 4, 5<, 84, 5, 6<, 85, 6, 7<<, 884, 5, 6<, 85, 6, 7<, 86, 7, 8<<<
8Sin@1D, Sin@2D, Sin@3D, Sin@4D,
Sin@5D, Sin@6D, Sin@7D, Sin@8D, Sin@9D, Sin@10D<
As these examples show, Table accepts one or more lists which indicate the iteration bounds, but we can
fill the lists with some functions computed on the counters being iterated. In cases when we have more
than one iterator, we create a nested list where the innermost iterators correspond to the outemost lists.
As we see, the bounds of the more outermost iterators may depend on the variables of more innermost
ones, in which case the lists will have sublists of different lengths. This is where we start seeing that lists
are more general than (multidimensional) arrays since the sublists are not bound to have the same dimen-
sions. Also, notice that lists created by Table are not bound to be lists of numbers - they can be lists of60
As these examples show, Table accepts one or more lists which indicate the iteration bounds, but we can
fill the lists with some functions computed on the counters being iterated. In cases when we have more
than one iterator, we create a nested list where the innermost iterators correspond to the outermost lists.
As we see, the bounds of the more outermost iterators may depend on the variables of more innermost
ones, in which case the lists will have sublists of different lengths. This is where we start seeing that lists
are more general than (multidimensional) arrays since the sublists are not bound to have the same dimen-
sions. Also, notice that lists created by Table are not bound to be lists of numbers - they can be lists of
functions:
Clear@i, xD;
Table@x ^ i, 8i, 1, 10<D
9x, x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 =
Here, for example, we created a 3x3 matrix of monomials:
Clear@i, j, xD;
Table@x ^ Hi +jL, 8i, 1, 3<, 8j, 1, 3<D
99x2 , x3 , x4 =, 9x3 , x4 , x5 =, 9x4 , x5 , x6 ==
One more comment about Table is that it is a scoping construct in the sense that it localizes its iterator
variables. It effectively uses Block[] scoping construct in doing so, with all the consequences which
normally accompany the use of Block[] (see section 4.8). In particular, naively we expect < f[i] > symbol
printed 5 times in the following example, since the definition of < f > used the global < i >
Clear@f, iD;
f := i ^ 2;
Table@f, 8i, 5<D
81, 4, 9, 16, 25<
The global < i > however did not receive any value :
i
i
The final comment about Table is that while it is a scoping construct, Return[] command can not be used
to break out of it, unlike some other scoping constructs we will encounter :
Table@If@i > 3, Return@D, iD, 8i, 10<D
81, 2, 3, Return@D, Return@D, Return@D,
Return@D, Return@D, Return@D, Return@D<
 3.4.4
A comment on universality of Range
As far as the first and the second examples are concerned, we can get the same result also with the Range
command. Observe:61
Range@10D ^ 0
Range@10D ^ 2
81, 1, 1, 1, 1, 1, 1, 1, 1, 1<
81, 4, 9, 16, 25, 36, 49, 64, 81, 100<
All other examples can also be done with Range and a small amount of functional programming:
HRange@3D * ðL &  Range@3D
881, 2, 3<, 82, 4, 6<, 83, 6, 9<<
Range@ð +1, 2 * ðD &  Range@4D
882<, 83, 4<, 84, 5, 6<, 85, 6, 7, 8<<
Nest@Partition@ð, 3, 1D &, Range@3, 8D, 2D
8883, 4, 5<, 84, 5, 6<, 85, 6, 7<<, 884, 5, 6<, 85, 6, 7<, 86, 7, 8<<<
Map@Sin, Range@10DD
8Sin@1D, Sin@2D, Sin@3D, Sin@4D,
Sin@5D, Sin@6D, Sin@7D, Sin@8D, Sin@9D, Sin@10D<
Clear@xD;
x ^ Range@10D
9x, x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10 =
The above examples may look unclear now. We give them here just to show that one can go a long way
with just the Range command, and to clarify the role of Table. In fact, Table can be thought of as an
optimized loop - it is usually (much) more efficient to create lists with Table rather than to do that in a
loop such as Do, For or While. But in the functional programming, Table is not so often used, unlike
Range, and now you can see why - we can always get the same effect, and moreover, very often do it
faster.62
 3.4.5
Generation of lists inside loops
 3.4.5.1
List generation with Append or Prepend
Such loop generation is possible and resembles most closely what we usually have in procedural lan-
guages. In Mathematica usually this is one of the least efficient ways to do this. Also, the Table command
is actually a loop, but optimized for list generation and fast. The direct list generation inside a loop
requires the commands Append, Prepend, AppendTo or PrependTo, starting with an empty list. Append
adds one element at the end of the list, and for reasons which we will explain later is very inefficient in
Mathematica for large lists. Let us instead illustrate this with an example. Here is a simple list generated
with Append:
For@testlist = 8<; i = 1, i £ 10,
i ++, testlist = Append@testlist, Sin@iDDD;
testlist
8Sin@1D, Sin@2D, Sin@3D, Sin@4D,
Sin@5D, Sin@6D, Sin@7D, Sin@8D, Sin@9D, Sin@10D<
This is how we do it with Range:
Sin@Range@10DD
8Sin@1D, Sin@2D, Sin@3D, Sin@4D,
Sin@5D, Sin@6D, Sin@7D, Sin@8D, Sin@9D, Sin@10D<
 3.4.5.2 A digression: <myTiming> : a useful function to measure small execution times
Here I introduce a (user - defined) utility function < myTiming >, which I will use heavily in various
performance measurements throughout the book :63
Clear@myTimingD;
myTiming@x_D := Module@8z = 0, y = 0, timelim = 0.1,
p, q, iterlist = HPower@10, ðD &  Range@0, 10DL,
nm =
If@ToExpression@StringTake@$Version, 1DD < 6, 2, 1
D<,
Catch@
If@Hz = Nest@
First, Timing@Hy ++; Do@x, 8ð<DL;D, nmDL > timelim,
Throw@8z, y<
D
D &  iterlistD . 8p_, q_< ¦ p  iterlist@@qDD
D;
Attributes@myTimingD = 8HoldAll<;
The code is a bit involved to explain now, but after reading through the book it may be a good idea to
revisit it, since it illustrates many points. Anyway, for now we are just users.
 3.4.5.3
Efficiency pitfall: constructing a list with Append
Let us compare the elapsed time of such list generation with that of Range, using the function myTiming :
Check now:
myTiming@For@testlist = 8<; i = 1,
i < 1000, i ++, testlist = Append@testlist, Sin@iDDD;D
0.19
myTiming@Sin@Range@1000DD;D
0.0013
We see that constructing a list of (symbolic) values of Sin on a thousand first natural numbers is hundred
times slower with Append than with Range. But the truth is that the computational complexities are
different and the larger is the list, the more overhead is induced by using Append. We can also see how
Table will perform:
myTiming@Table@Sin@iD, 8i, 1000<D;D
0.0023
We see that it is a little slower than Range.
In addition to being slower, the generation with the loop introduced a global side effect - the variable
<testlist>. So, to make the code clean, one will have in this approach to wrap the loop in an additional
modularization construct and thus make it even clumsier.
So, in conclusion, I would thoroughly discourage the reader from straightforward list generation inside a
loop. First, there are almost always better design solutions which avoid this problem altogether. Second,
there exist workarounds to get a linear time performance in doing it, such as using linked lists (to be
discussed below), or indexed variables. Finally, starting with version 5, there are special commands Reap
and Sow introduced specifically for efficient generation and collection of intermediate results in computa -
tions - we will have an entire chapter in the part II devoted to these commands.64
So,
in conclusion, I would thoroughly discourage the reader from straightforward list generation inside a
loop. First, there are almost always better design solutions which avoid this problem altogether. Second,
there exist workarounds to get a linear time performance in doing it, such as using linked lists (to be
discussed below), or indexed variables. Finally, starting with version 5, there are special commands Reap
and Sow introduced specifically for efficient generation and collection of intermediate results in computa -
tions - we will have an entire chapter in the part II devoted to these commands.
3.5
Internal (full) form of lists
Let me emphasize once again that internal form of lists satisfies the general requirement of how normal
expressions are built in Mathematica (see chapter I). For example, here are simple and nested lists:
Clear@testlist, complextestlistD;
testlist = Range@10D
complextestlist = Range  Range@5D
81, 2, 3, 4, 5, 6, 7, 8, 9, 10<
881<, 81, 2<, 81, 2, 3<, 81, 2, 3, 4<, 81, 2, 3, 4, 5<<
And here are their full forms:
FullForm@testlistD
List@1, 2, 3, 4, 5, 6, 7, 8, 9, 10D
FullForm@complextestlistD
List@List@1D, List@1, 2D, List@1, 2, 3D, List@1, 2, 3, 4D, List@1, 2, 3, 4, 5DD
This shows in particular that list indexing can be performed in the same way as indexing of more general
normal Mathematica expressions, outlined in chapter I. We will use this fact in the next subsection.
Clear@testlist, complextestlistD;
3.6
Working with lists and their parts
 3.6.1 List indexing and element extraction with the Part command
 3.6.1.1
Simple lists
Consider a simple list:
Clear@testlistD;
testlist = Range@1, 20, 3D
81, 4, 7, 10, 13, 16, 19<
Say we need to extract its first element. This is accomplished as follows:
testlist@@3DD
7
Or, which is the same, like this:65
Part@testlist, 3D
7
Now, let us say we need to extract second, fourth and fifth elements. This is how:
testlist@@82, 4, 5<DD
84, 10, 13<
Or, which is the same:
Part@testlist, 82, 4, 5<D
84, 10, 13<
List elements can be also counted from the end of the list. In this case, their positions are negative by
convention:
testlist@@-1DD
19
 3.6.1.2
Working with nested lists
Consider now a more complex list:
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
Its elements of level one (we remind that level is the "distance from the stem", see section 1.1.7) are its
sublists:
complextestlist@@2DD
810, 11, 12, 13, 14<
complextestlist@@81, 4, 5<DD
885, 6, 7, 8, 9<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
To get to the numbers, we need in this case a 2-number indexing (since all sublists have a depth 1. Should
they have depth N, we would need N+1 indexes, and should the depth be different for different sublists,
the number of necessary indices would accordingly be different)
complextestlist@@1, 1DD
5
which means "first element of the first element" (we can view this list as a 2-dimensional array). Notice
that the syntax complextestlist[[{1,1}]] will be interpreted as a twice repeated first element of the original
list, i.e. twice repeated first sublist:
complextestlist@@81, 1<DD
885, 6, 7, 8, 9<, 85, 6, 7, 8, 9<<
Everything that was true for simple lists, is also true here:66
complextestlist@@-1DD
complextestlist@@-1, -1DD
825, 26, 27, 28, 29<
29
Clear@testlist, complextestlistD;
 3.6.2
Extract
This operator is analogous to the Part operator, with some extra functionality which is sometimes very
useful but of no interest for us at the moment. What is important now, is that it can extract several ele-
ments at different levels at the same time (Part can also extract several elements, but they have to be at the
same level). Also, Extract has a different syntax - to extract an element on the level deeper than the first
(and also, every time when we extract more than one element), the address of the element being extracted
should be entered as a list of indices:
testlist = Range@1, 20, 3D;
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
Extract@testlist, 1D
Extract@complextestlist, 1D
Extract@complextestlist, 81, 2<D
1
85, 6, 7, 8, 9<
6
Extract@complextestlist, 881, 2<, 83<, 84, 5<<D
86, 815, 16, 17, 18, 19<, 24<
 3.6.3
Take and Drop
These commands are used to take or drop from a list several elements in a row. For example, here are
again our lists:
testlist = Range@1, 20, 3D
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
81, 4, 7, 10, 13, 16, 19<
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
And these are examples of how Take and Drop work67
Take@testlist, 3D
81, 4, 7<
Take@testlist, 82, 4<D
84, 7, 10<
Take@testlist, -3D
813, 16, 19<
Take@testlist, 8-4, -3<D
810, 13<
Drop@testlist, 3D
810, 13, 16, 19<
Drop@testlist, 82, 4<D
81, 13, 16, 19<
Drop@testlist, -3D
81, 4, 7, 10<
Drop@testlist, 8-4, -3<D
81, 4, 7, 16, 19<
Both Take and Drop also have some extended functionality to automate structural operations performed
on nested lists, such as extraction of submatrices from matrices. We don’t cover them here, but they are
described in Mathematica Help.
 3.6.4
First, Rest, Last and Most
This commands are is in principle redundant, since First[list] is exactly equivalent to list[[1]], Rest[list] is
equivalent to Drop[list,1], Last[list] is equivalent to list[[-1]], and Most[list] is equivalent to Drop[list,-1].
However, they can be used for better code readability.
 3.6.5
Length
This command returns the length of the list. For instance:68
testlist = Range@1, 20, 3D
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
81, 4, 7, 10, 13, 16, 19<
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
8Length@testlistD, Length@complextestlistD<
87, 5<
If we want to compute the lengths of sublists in <complextestlist>, this can be done as follows:
Table@Length@complextestlist@@iDDD, 8i, 1, Length@complextestlistD<D
85, 5, 5, 5, 5<
Here, obviously, the index <i> is used to index the sublists, and thus it runs from 1 to the length of the
main list, while the Part operation [[i]] extracts the sublists.
 3.6.6
Modification of list elements by direct indexing (using Part)
 3.6.6.1
Simple uses of Part
If it is necessary to replace some element of the list with a known address with some new expression or
value (say, symbol <a>), this can be done directly. Here are our lists:
Clear@aD;
testlist = Range@1, 20, 3D
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
81, 4, 7, 10, 13, 16, 19<
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
Say, we now want to replace the element with the address {5} with <a>:
testlist@@5DD = a;
testlist
81, 4, 7, 10, a, 16, 19<
Now, let us now in our list <complextestlist> replace a random element in every sublist with <a>:
For@i = 1, i £ Length@complextestlistD, i ++,
complextestlist@@i, Random@Integer, 81, 5<DDD = aD;
complextestlist
885, 6, 7, 8, a<, 810, 11, a, 13, 14<,
815, 16, 17, 18, a<, 820, 21, a, 23, 24<, 825, 26, 27, a, 29<<
Notice that such modifications as described above are only possible if lists are stored in some variable (in
C we would say, that it is an L-value). In particular, this input is a mistake:69
Range@10D@@3DD = a
Set::setps : Range@10D in the part assignment is not a symbol. 
a
Essentially, in all the above examples the Part command ([[ ]] ) was used for modification of expressions.
Note also that the modification of lists with Part introduces side effect, since it is the original variable
where the list is stored that is modified, not the copy of the list.
 3.6.6.2
Use Part to efficiently modify large structures
One more thing I would like to mention here is that Part has a very powerful extended functionality which
allows to change many elements at the same time. For example, if I want to change second element in
each sublist of < complextestlist > to < b > and fourth to < c >, I can do this in the following way :
Part@complextestlist, All, 2D = 8b, c, d, e, f<;
complextestlist
885, b, 7, 8, a<, 810, c, a, 13, 14<,
815, d, 17, 18, a<, 820, e, a, 23, 24<, 825, f, 27, a, 29<<
This turns out to be very handy in cases when many elements have to be changed at once. This is however
limited to cases when these parts form some rather regular structures like sub-matrices etc. For more
details, see Mathematica Help and Mathematica Book, also the description on the web site of Ted Ersek
(see Appendices for the URL).
 3.6.7 ReplacePart
There is another built-in command used to modify list elements - ReplacePart. But there is a big difference
between direct modifications by subscripting (Part) used above, and the functionality of the ReplacePart
command. Notice that as a result of our manipulations with Part, the original lists has been modified.
However, more often in Mathematica programs we would modify a list which is not the original list but a
copy, so that the original list remains unchanged. This style of programming is arguably cleaner but
requires more memory since the original object is copied. Most built-in functions act in this manner. In
particular, this is the case with ReplacePart:
Clear@aD;
testlist = Range@1, 20, 3D
81, 4, 7, 10, 13, 16, 19<
ReplacePart@testlist, a, 5D
81, 4, 7, 10, a, 16, 19<
But the original list:
testlist
81, 4, 7, 10, 13, 16, 19<
remained unchanged. This also means that ReplacePart does not require L-value to operate on an
expression:70
ReplacePart@Range@10D, a, 5D
81, 2, 3, 4, a, 6, 7, 8, 9, 10<
No error in this case - since it did not attempt to change the original list but rather changed the copy of it.
The ReplacePart can be used to change more than a single element at a time, also elements on different
levels of expression. For example:
ReplacePart@Range@10D, a, 882<, 85<, 88<<D
81, a, 3, 4, a, 6, 7, a, 9, 10<
Note that the syntax regarding the list of positions is the same as for the Extract command. ReplacePart is
described in detail in Mathematica Help.
I have to mention however, that ReplacePart can become quite slow if one wants to change many parts of
a large expression at the same time. For a detailed discussion, please see Appendix C.
Neither do I recommend to use ReplacePart in such cases by changing elements one by one (say, inside a
loop) rather than all at once. The reason is that since it effectively copies the entire list and then performs
changes on the copy, it will in such a sequential approach copy the entire list as many times as is the total
number of replacements. This will be terribly inefficient, just as with Append and Prepend operators. In
some of these cases one can efficiently use Part to change many elements at once - one such example we
will consider in chapter VI (see section 6.5.5.1).
 3.6.8 Position
The Position command is used to determine the positions of elements in a list (or more general Mathemat-
ica expression) which match a given expression, either exactly, or through patterns.
 3.6.8.1 Basic uses of Position
In the simplest form, Position has the following format: Position[list,element] . Let us give a few
examples:
First we initialize our lists:
testlist = Range@1, 20, 3D
complextestlist = Range@5 * ð, 5 * ð +4D &  Range@5D
81, 4, 7, 10, 13, 16, 19<
885, 6, 7, 8, 9<, 810, 11, 12, 13, 14<,
815, 16, 17, 18, 19<, 820, 21, 22, 23, 24<, 825, 26, 27, 28, 29<<
We will now use the simplest version of Position (without patterns) to obtain all positions where the
number <4> is found in a list:
Position@testlist, 4D
882<<
This means that number 4 is the second element in <testlist>71
Position@complextestlist, 12D
882, 3<<
This means that number 12 is the third element of the second element (sublist) of the list
<complextestlist>.
The Position command can be used together with the Extract command, since they use the same position
specifications:
Extract@complextestlist, Position@complextestlist, 10DD
810<
 3.6.8.2 On less trivial uses of Position
This does not look like a big deal, but we may for example wish to extract the entire sublist containing 10.
All we have to do is to construct a new position list, with the last element (index) dropped:
Map@Most, Position@complextestlist, 10DD
882<<
The functionality of Map will be discussed much later, but essentially here it will ensure that if the position
list contains several positions, the last index will be dropped from all of them. For example, here we
define another nested list in which some numbers are found more than once:
complextestlist1 = Range  Range@6D
881<, 81, 2<, 81, 2, 3<, 81, 2, 3, 4<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
These are all the positions where number 4 is found:
plist = Position@complextestlist1, 4D
884, 4<, 85, 4<, 86, 4<<
If we use these positions in Extract, we just get number 4 extracted 3 times:
Extract@complextestlist1, plistD
84, 4, 4<
However, if we want to extract all the sublists containing 4, we need one more step. To obtain the posi-
tions of sublists only, we have to delete the last index from each of the sublists in <plist>:
Map@Most, plistD
884<, 85<, 86<<
Now we can extract sublists:
Extract@complextestlist1, Map@Most, plistDD
881, 2, 3, 4<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
 3.6.8.3 Example: extracting sublists containing given element
Now we will write our first "serious" function: it will extract those sublists from a list, which contain a
given element.72
Clear@sublistsWithElementD;
sublistsWithElement@main_List, elem_D :=
Extract@main, Map@Most, Position@main, elemDDD;
For example, these are the sublists of <complextestlist1> which contain number 5:
sublistsWithElement@complextestlist1, 5D
881, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
I used this opportunity to illustrate several common features of user-defined functions in Mathematica.
First, the development of the function: it is usually best to start with some simple test example, develop
the code in steps like above, and then package everything into a function. Second, we saw that the parame -
ters in the function definition on the l.h.s. contain an underscore. This is a sign that patterns are used in the
definition. For now, I will just briefly mention that pattern like <x_> means "any expression" and automati-
cally makes <x> local for the r.h.s., if SetDelayed (:=)was used in the definition (which is normally the
case for functions). The pattern x_h means "anything with the head <h>". Thus, the pattern <main_List>
above will match on any list, but not on a more general expression whose head is not List. This constitutes
a simple type-check.
The other comment about Position function is due here: it is important to remember that while this is an
optimized and fast built-in function, it is still a general-purpose one. In particular, if you have a list sorted
with respect to some criteria, it will be typically much faster for large lists to search for an element with a
version of a binary search, which you can implement in Mathematica (and which has a logarithmic com-
plexity) than with the Position function (which has a linear complexity).
 3.6.8.4
More complicated example - sublists with odd number of odd elements
The problem
We will now illustrate the use of Position with patterns on a somewhat less trivial example. Please ignore
the pieces of syntax you are not yet familiar with but rather concentrate on the conceptual part and con-
sider this as an illustration. The problem will be to extract from <complextestlist1> all sublists which have
an odd number of odd elements. Our solution will go in steps.
complextestlist1 = Range  Range@6D
881<, 81, 2<, 81, 2, 3<, 81, 2, 3, 4<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
Developing a solution
Step1: Find all positions of all odd numbers:
step1list = Position@complextestlist1, _ ? OddQD
881, 1<, 82, 1<, 83, 1<, 83, 3<, 84, 1<,
84, 3<, 85, 1<, 85, 3<, 85, 5<, 86, 1<, 86, 3<, 86, 5<<
In each of the small sublists, as we already know, the first index gives the number of sublist in
<compextestlist1>, and the second one gives the index of the given odd element in this sublist.
Step 2: We combine together the addresses which correspond to the same sublist - they have the same first
element:73
step2list = Split@step1list, First@ð1D  First@ð2D &D
8881, 1<<, 882, 1<<, 883, 1<, 83, 3<<, 884, 1<, 84, 3<<,
885, 1<, 85, 3<, 85, 5<<, 886, 1<, 86, 3<, 86, 5<<<
The Split is another built-in command which we will cover shortly and whose purpose is to split a list into
sublists of the "same" elements, where the notion of "same" can be defined by the user. In particular, in
this case we tell Split to consider sublists of indices "same" if they have the same first element. Notice
that now they are combined in extra lists.
Step 3: Leave in the lists only the first elements:
step3list = Map@First, step2list, 82<D
881<, 82<, 83, 3<, 84, 4<, 85, 5, 5<, 86, 6, 6<<
Step4: In the above lists, leave only the sublists with odd length (the length of these sublists corresponds to
the number of odd elements in the sublists of our original list, with addresses equal to numbers repeated in
the sublists above).
step4list = Cases@step3list, x_List ; OddQ@Length@xDDD
881<, 82<, 85, 5, 5<, 86, 6, 6<<
<Cases> is the command used to find the list of all occurrences of some expression or pattern in a larger
expression. We will cover it later.
Step5: Replace all sublists by their first elements:
step5list = Union@Flatten@step4listDD
81, 2, 5, 6<
<Flatten> makes any list flat, and <Union> removes duplicate elements and sorts the resulting list.
Step 6: Extracting the sublists:
complextestlist1@@step5listDD
881<, 81, 2<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
Assembling the code into a function
We can compress all the steps into a single function:
Clear@oddSublistsD;
oddSublists@x_ListD :=
Part@x, Union@Flatten@Cases@Map@First, Split@Position@x, _ ? OddQD,
First@ð1D  First@ð2D &D, 82<D, y_List ; OddQ@Length@yDDDDDD
Check:74
oddSublists@complextestlist1D
881<, 81, 2<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
An alternative functional implementation
There is a much simpler but less obvious way to do the same thing by using the mixed rule-based and
functional programming style. I will give here the code just for an illustration:
Clear@oddSublistsNewD;
oddSublistsNew@x_ListD :=
Map@If@EvenQ@Count@ð, _ ? OddQDD, ð . ð ® Sequence@D, ðD &, xD;
Check:
oddSublistsNew@complextestlist1D
881<, 81, 2<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
While the first realization became significantly complex to question the advantage of this programming
style compared to a traditional procedural programming based on nested loops, my primary goal here was
to illustrate the use of Position command, and perhaps give a flavor of a few others.
However, the second realization is clearly shorter. This kind of programs can be written very quickly and
are typically very short.
A procedural version
It is also less bug-prone than the possible procedural implementation based on 2 nested loops:
Clear@oddSublistsProcD;
oddSublistsProc@x_ListD := Module@8pos = 8<, ctr, i, j<,
For@i = 1, i £ Length@xD, i ++,
For@j = 1; ctr = 0, j £ Length@x@@iDDD,
j ++, If@OddQ@x@@i, jDDD, ctr ++D;D;
If@OddQ@ctrD, AppendTo@pos, iDD;D;
Return@x@@posDDDD;
Check:
oddSublistsProc@complextestlist1D
881<, 81, 2<, 81, 2, 3, 4, 5<, 81, 2, 3, 4, 5, 6<<
Apart from being clumsier, this code also uses AppendTo to append elements to a list, which will make it
inefficient for large lists, just as in the examples we considered before.
Clear@complextestlist1, step1list, step2list, step3list, step4list,
step5list, oddSublists, oddSublistsNew, oddSublistsProcD;75
3.7
Adding elements to the list and removing them from the list
 3.7.1
Append, Prepend, AppendTo and PrependTo
Some of these commands we have already encountered before. They add an element to the end or to the
beginning of the list. For example:
Clear@aD;
testlist = Range@5D
81, 2, 3, 4, 5<
Append@testlist, aD
81, 2, 3, 4, 5, a<
Prepend@testlist, aD
8a, 1, 2, 3, 4, 5<
testlist
81, 2, 3, 4, 5<
The last output shows that the list <testlist> did not change. As we discussed, the absence of side-effects is
typical for Mathematica built-in functions. In this case, Append and Prepend forged a copy of <testlist>
and modified this copy. If we want an original list to be modified, we have either to write:
testlist = Append@testlist, aD;
testlist
81, 2, 3, 4, 5, a<
or, which is equivalent, to use the function AppendTo, which does exactly this:
testlist = Range@5D
81, 2, 3, 4, 5<
AppendTo@testlist, aD;
testlist
81, 2, 3, 4, 5, a<
The situation with Prepend and PrependTo is completely analogous. And also, recalling the previous
discussions, we may suspect that the application of AppendTo or PrependTo to a list which is not assigned
to any variable (not an L-value) is a mistake, and we will be correct:
Append@Range@5D, aD
81, 2, 3, 4, 5, a<76
AppendTo@Range@5D, aD
Set::write : Tag Range in Range@5D is Protected. More1⁄4
81, 2, 3, 4, 5, a<
As we already discussed, it is best to avoid using these functions (Append etc) for modifying large lists.
Later we will consider several more efficient alternatives.
Clear@testlistD;
 3.7.2
Insert and Delete
As is clear from their names, these functions are used to insert an element to or delete it from the list, or
more general Mathematica expression. These operations are well described in Mathematica Help. We
will give just a few examples of their use. The format of Insert is Insert[list,new,pos] - this will insert the
new element <new> in the position <pos> in the list <list>. Delete has a similar syntax Delete[list,pos]
and respectively deletes from the list <list> an element at position <pos>. For example:
Clear@aD;
testlist = Range@3, 15, 2D
83, 5, 7, 9, 11, 13, 15<
Delete@testlist, 4D
83, 5, 7, 11, 13, 15<
Insert@testlist, a, 5D
83, 5, 7, 9, a, 11, 13, 15<
Notice that once again, both of these commands work on the copy of the original list that they create, so
that the original list remains unchanged:
testlist
83, 5, 7, 9, 11, 13, 15<
Both of these commands can work on nested lists (or more general expressions), and then the position will
be a list of indexes. Also, they may also receive a list of positions rather than a single position - in this
case, an element will be inserted or deleted in many places at once.
However, in the case of Insert, it may become quite slow if a large number of parts have to be inserted at
the same time. For a more detailed discussion, please see the Appendix C.77
3.8
Working with nested lists
It is often necessary to work with nested lists, that is - lists whose elements themselves are lists. We have
seen simple examples of such lists already. Let me emphasize that in general such lists are not identical to
multidimensional arrays but in fact much more general, because the lengths of sublists at each level can be
different. The only thing we can say about the general nested list is that it represents some tree.
Here we will consider several special-purpose commands which were designed for efficient processing of
some special types of such nested lists.
 3.8.1 Partition
This command is used to "cut" or "slice" some list into (possibly overlapping) pieces. In its simplest form,
it has a format Partition[list, size, shift]. It cuts the list into pieces with the length <size>, and shifted one
with respect to another by <shift>. If the <shift> parameter is not given, the list is cut into non-overlapping
pieces. For example:
 3.8.1.1 A simple example
testlist = Table@Sqrt@iD, 8i, 1, 10<D
:1,
2,
3 , 2,
5,
6,
Partition@testlist, 3D
::1,
2,
3 >, :2,
5,
7,2
6 >, : 7 , 2
Partition@testlist, 7D
::1,
2,
3 , 2,
5,
10 >
2 , 3,
2 , 3>>
7 >>
6,
In the last example, the remaining piece had a size smaller than 7, so it was "eaten up". Now we will
partition with overlaps:
Partition@testlist, 7, 1D
::1,
2,
: 3 , 2,
3 , 2,
5,
6,
5,
6,
7,2
7 >, : 2 ,
2 , 3>, :2,
3 , 2,
5,
6,
5,
6,
7,2
7,2
2 , 3,
2 >,
10 >>
 3.8.1.2 An example of practical use: computation of the moving average in a list.
This example is based on a similar discussion in Wagner’ 96.
The problem
The m-moving average for a list is an average which is obtained by averaging every element in a list with
<m> neighbors to the right and to the left (which means that this quantity is only defined for points
(elements) having at least m neighbours both to the left and to the right). Thus, moving average is actually
a list of such averages, of the length <len>-2m, where <len> is a length of an initial list.78
The m-moving average for a list is an average which is obtained by averaging every element in a list with
<m> neighbors to the right and to the left (which means that this quantity is only defined for points
(elements) having at least m neighbors both to the left and to the right). Thus, moving average is actually
a list of such averages, of the length <len>-2m, where <len> is a length of an initial list.
Developing a solution
To solve our problem, we will first define an auxiliary function which will count the average of a list of
numbers. However, it will turn out that our function will also work on a list of lists of numbers, this time
summing entire lists (with the same number of elements) together, which we will use. So:
Clear@listAverageD;
listAverage@x_ListD := Apply@Plus, xD  Length@xD;
The expression Apply[Plus,x] computes the sum of elements in the list and its meaning will be explained
in chapter V.
Now we will define another auxiliary function:
Clear@neighborListsD;
neighborLists@x_List, m_IntegerD :=
Partition@x, Length@xD -2 * m, 1D;
For example:
neighborLists@testlist, 1D
::1,
: 2,
2,
3 , 2,
5,
6,
3 , 2, 5, 6,
5, 6, 7,2
: 3 , 2,
7,2
7,2
2 >,
2 , 3>,
2 , 3,
10 >>
Let us now realize that the middle list represents a list of "middle points", and the first and the last list
represent here lists of closest "neighbors" for these middle points. Thus, the only thing left to do is to use
listAverage on this result:
listAverage@neighborLists@testlist, 1DD
:
1
1
J1 + 2 + 3 N, J2 + 2 + 3 N,
3
3
1
1
1
J2 + 3 + 5 N, J2 + 5 + 6 N, J 5 + 6 + 7 N,
3
3
3
1
1
1
J2 2 + 6 + 7 N, J3 +2 2 + 7 N, J3 +2 2 + 10 N>
3
3
3
Packaging code to a function
Thus, our final function <movingAverage>will look like:79
Clear@movingAverage, neighborLists, listAverageD;
neighborLists@x_List, m_IntegerD :=
Partition@x, Length@xD -2 * m, 1D;
listAverage@x_ListD := Apply@Plus, xD  Length@xD;
movingAverage@x_List, m_IntegerD :=
listAverage@neighborLists@x, mDD;
For example, here we find the moving average with two neighbors on each side:
movingAverage@testlist, 2D
1
1
J3 + 2 + 3 + 5 N, J2 + 2 + 3 + 5 + 6 N,
5
5
1
1
J2 + 3 + 5 + 6 + 7 N, J2 +2 2 + 5 + 6 + 7 N,
5
5
1
1
J3 +2 2 + 5 + 6 + 7 N, J3 +2 2 + 6 + 7 + 10 N>
5
5
:
Using functional programming to eliminate auxiliary functions
With the help of the functional programming syntax, we can write this as a single function and eliminate
the need in auxiliary functions altogether:
Clear@movingAverageD;
movingAverage@x_List, m_IntegerD :=
HPlus  ðL  Length@ðD &  Partition@x, Length@xD -2 * m, 1D;
Check:
movingAverage@testlist, 2D
:
1
1
J3 + 2 + 3 + 5 N, J2 + 2 + 3 + 5 + 6 N,
5
5
1
1
J2 + 3 + 5 + 6 + 7 N, J2 +2 2 + 5 + 6 + 7 N,
5
5
1
1
J3 +2 2 + 5 + 6 + 7 N, J3 +2 2 + 6 + 7 + 10 N>
5
5
A procedural version
Here is the procedural implementation of the same thing:80
movingAverageProc@x_List, m_IntegerD :=
Module@8i, j, ln = Length@xD, aver, sum<,
aver = Table@0, 8ln -2 * m<D;
For@i = m +1, i <= ln -m, i ++,
sum = 0;
For@j = i -m, j £ i +m, j ++,
sum = sum +x@@jDDD;
aver@@i -mDD = sum  H2 * m +1LD;
averD;
Check:
movingAverageProc@testlist, 2D
:
1
1
J3 + 2 + 3 + 5 N, J2 + 2 + 3 + 5 + 6 N,
5
5
1
1
J2 + 3 + 5 + 6 + 7 N, J2 +2 2 + 5 + 6 + 7 N,
5
5
1
1
J3 +2 2 + 5 + 6 + 7 N, J3 +2 2 + 6 + 7 + 10 N>
5
5
Efficiency comparison
The problem with the procedural version is not just that the code is longer, but also that it is more error
prone (array bounds, initialization of variables etc). On top of that, it turns out to be far less efficient. Let
us compare the efficiency on large lists:
Timing@movingAverage@Range@10 000D, 10D;D
80.016 Second, Null<
Timing@movingAverageProc@Range@10 000D, 10D;D
81.172 Second, Null<
Here we have a 100 times difference (for this length of the list)! And moreover, this is not a constant
factor, but the difference will increase further with the length of the list. Of course, in procedural lan-
guages such as C the latter implementation is natural and fast. Not so in Mathematica. However, one can
still obtain the code which will be concise, fast and elegant at the same time, with the use of functional
programming methods.
Clear@testlistD;81
 3.8.2
Transpose
This is one of the most useful commands. It has this name since for matrices, which are represented as 2-
dimensional lists of lists, it performs the transposition operation. However, we are not forced to always
interpret the two-dimensional array as a matrix, especially if it is combined from elements of different
types. Then it turns out that the number of useful things one can do with Transpose is much larger. But let
us start with the numeric lists: say we have a given list of lists of some elements (they may be lists them-
selves, but this does not matter for us):
 3.8.2.1 Simple example: transposing a simple matrix
testlist = Table@i +j, 8i, 1, 2<, 8j, 1, 3<D
882, 3, 4<, 83, 4, 5<<
Then,
Transpose@testlistD
882, 3<, 83, 4<, 84, 5<<
 3.8.2.2 Example: transposing a matrix of lists
Another example:
testlist = Table@8i, j<, 8i, 1, 2<, 8j, 1, 3<D
8881, 1<, 81, 2<, 81, 3<<, 882, 1<, 82, 2<, 82, 3<<<
This is a 2-dimensional array of lists.
Transpose@testlistD
8881, 1<, 82, 1<<, 881, 2<, 82, 2<<, 881, 3<, 82, 3<<<
 3.8.2.3
Example: combining names with grades
Another example: we have results of some exam - the scores - as a first list, and last names of the students
as another one. We want to make a single list of entries like {{student1,score1},...}.
Clear@names, scoresD;
names = 8"Smith", "Johnson", "Peterson"<;
scores = 870, 90, 50<;
Then we do this:
Transpose@8names, scores<D
88Smith, 70<, 8Johnson, 90<, 8Peterson, 50<<
But we will get most out of Transpose when we get to functional programming, since Transpose is very
frequently used there for efficient structure rearrangements. We will see many examples of its use in the
chapters that follow.
 3.8.3 Flatten82
3.8.3 Flatten
This command is used to destroy the structure of nested lists, since it removes all internal curly braces and
transforms any complicated nested list into a flat one. For example:
 3.8.3.1 Simple example: flattening a nested list
testlist = Table@8i, j<, 8i, 1, 2<, 8j, 1, 3<D
8881, 1<, 81, 2<, 81, 3<<, 882, 1<, 82, 2<, 82, 3<<<
Flatten@testlistD
81, 1, 1, 2, 1, 3, 2, 1, 2, 2, 2, 3<
 3.8.3.2 Flattening down to a given level
One can make Flatten more "merciful" and selective by instructing it to destroy only braces up to (or,
more precisely, down to) a certain level in an expression. The level up to which the "destruction" has to be
performed is given to Flatten as an optional second parameter. For instance:
Flatten@testlist, 1D
881, 1<, 81, 2<, 81, 3<, 82, 1<, 82, 2<, 82, 3<<
Example: flattening a nested list level by level
Another example:
testlist = Table@8i, j, k<, 8i, 1, 2<, 8j, 1, 2<, 8k, 1, 3<D
88881, 1, 1<, 81, 1, 2<, 81, 1, 3<<, 881, 2, 1<, 81, 2, 2<, 81, 2, 3<<<,
8882, 1, 1<, 82, 1, 2<, 82, 1, 3<<, 882, 2, 1<, 82, 2, 2<, 82, 2, 3<<<<
Flatten@testlist, 1D
8881, 1, 1<, 81, 1, 2<, 81, 1, 3<<, 881, 2, 1<, 81, 2, 2<, 81, 2, 3<<,
882, 1, 1<, 82, 1, 2<, 82, 1, 3<<, 882, 2, 1<, 82, 2, 2<, 82, 2, 3<<<
Flatten@testlist, 2D
881, 1, 1<, 81, 1, 2<, 81, 1, 3<, 81, 2, 1<, 81, 2, 2<, 81, 2, 3<,
82, 1, 1<, 82, 1, 2<, 82, 1, 3<, 82, 2, 1<, 82, 2, 2<, 82, 2, 3<<
Flatten@testlist, 3D
81, 1, 1, 1, 1, 2, 1, 1, 3, 1, 2, 1, 1, 2, 2, 1, 2,
3, 2, 1, 1, 2, 1, 2, 2, 1, 3, 2, 2, 1, 2, 2, 2, 2, 2, 3<
In practice, most frequently one uses either Flatten[expr] to get a completely flat list, or Flatten[expr,1]
to remove some internal curly braces which were needed at some intermediate steps but not anymore.
  3.8.3.3 Application: a computation of quadratic norm of a tensor of arbitrary rank (vector, matrix
etc).83
3.8.3.3 Application: a computation of quadratic norm of a tensor of arbitrary rank (vector, matrix
etc).
The problem and the solution
Here we will show how the use of Flatten can dramatically simplify the computation of the norm of a
tensor of arbitrary rank. What may be surprising is that we will not need the rank of the tensor as a sepa -
rate parameter. So, we wil start with the code:
Clear@tensorNormD;
tensorNorm@x_ListD := Sqrt@Plus  Flatten@x ^ 2DD;
It turns out that this tiny code is all what is needed to solve the problem in all generality.
Code dissection
Let us use an example to show how it works. This will be our test matrix:
testmatr = Table@i +j, 8i, 1, 3<, 8j, 1, 3<D
882, 3, 4<, 83, 4, 5<, 84, 5, 6<<
The norm is the square root of sum of the squares of all matrix elements. First, we will use the fact that
arithmetic operations such as raising to some power, can be used on entire lists, because they are automati-
cally threaded over the elements of the list (functions which have this property are said to be Listable).
Thus, we first square all the elements:
testmatr^ 2
884, 9, 16<, 89, 16, 25<, 816, 25, 36<<
Since we don’t care which elements are where but just need to sum them all, we will use Flatten to remove
the internal curly braces:
Flatten@testmatr^ 2D
84, 9, 16, 9, 16, 25, 16, 25, 36<
Now we have to some all the elements, and as we saw already this can be done for instance with Plus@@
construction:
Plus  Flatten@testmatr^ 2D
156
Finally, we have to take a square root:
Sqrt@Plus  Flatten@testmatr^ 2DD
2
39
And we arrive at the code of our function. We see that the function works well on a tensor of any rank
without modifications! It would be hard to do this without Flatten, and in particular, in languages like C
we would need nested loops to accomplish this (in C, there is also a technique called flattening an array,
which consists in exploiting the row-major order in which it is stored in memory and going through the
multidimensional
array with just a pointer to an integer (or whatever is the type of the smallest array

element). Although it usually works, it will be illegal if one wants to strictly adhere to the C standard).And we arrive at the code of our function. We see that the function works well on a tensor of any rank
modifications! It would be hard to do this without Flatten, and in particular, in languages like C
we would need nested loops to accomplish this (in C, there is also a technique called flattening an array,
which consists in exploiting the row-major order in which it is stored in memory and going through the
multidimensional array with just a pointer to an integer (or whatever is the type of the smallest array
element). Although it usually works, it will be illegal if one wants to strictly adhere to the C standard).
84
without
Clear@tensorNorm, testmatrD;
 3.8.3.4 Application - (relatively) fast list generation with Flatten
As we already mentioned, generating lists straightforwardly in loops is perhaps the worst way to do it, in
terms of efficiency. One can use Flatten to speed-up this process considerable. Say, we want to generate a
list from 1 to 10 (which is easiest to do, of course, by just using Range[10]). We can do it in the following
fashion:
Step 1. We generate a nested list (this type of lists are also called linked lists in Mathematica):
For@testlist = 8<; i = 1, i £ 10, i ++, testlist = 8testlist, i<D;
testlist
88888888888<, 1<, 2<, 3<, 4<, 5<, 6<, 7<, 8<, 9<, 10<
Step 2. We use Flatten:
Flatten@testlistD
81, 2, 3, 4, 5, 6, 7, 8, 9, 10<
Let us compare the execution time with the realization with Append described previously:
For@testlist = 8<; i = 1, i < 5000, i ++, AppendTo@testlist, iDD; 
Timing
80.25 Second, Null<
Now, with our new method:
HFor@testlist = 8<; i = 1, i < 5000, i ++, testlist = 8testlist, i<D;
Flatten@testlistD;L  Timing
80.016 Second, Null<
We see that the difference is about an order of magnitude at least. While even this method by itself is not
the most efficient, we will later see how linked lists can be used in certain problems to dramatically
improve efficiency.
Clear@testlistD;
3.9
Working with several lists
It is often necessary to obtain unions, intersections, and complements of two or more lists, and also to
remove duplicate elements from a list. This is done by such built-in commands as Join, Intersection,
Complement and Union.85
 3.9.1
The Join command
The Join command joins together two or several lists. The format of it is Join[list1,...,listn], where
<list1,..., listn> are lists, not necessarily of the same depth or structure. If the lists contain identical ele-
ments, the elements are not deleted - i.e., the lists are joined together as is, with no further modification of
their internal structure. Examples:
Clear@a, b, c, d, e, fD;
Join@8a, b, c<, 8d, e, f<D
8a, b, c, d, e, f<
Join@88a, b<, 8c, d<<, 8e, f<D
88a, b<, 8c, d<, e, f<
Join connects lists together from left to right, as they are, without any sorting or permuting the elements.
 3.9.2 The Intersection command
The Intersection command finds the intersection of two or more lists, that is a set of all elements which
belong to all of the intersected lists. The format of the command : Intersection[list1, ..., listn]. Examples:
Clear@a, b, c, d, e, fD;
Intersection@8a, b, c<, 8b, c, d, e<D
8b, c<
Intersection@8a, b, c, d, e, f<, 8a, b, c<, 8c, d, e<D
8c<
Intersection@8a, b, c<, 8d, e, f<D
8<
In the latter case we got an empty list, because the intersection of the latter two lists is empty.
The Intersection command has an option SameTest which can be used to provide a custom "sameness"
function - this way we can define our notion of "same" different from the default one. Please see the
Union command for an example of use of this option. Also, with this option, Intersection may be slower or
much slower than in its "pure" form. For a more detailed discussion, please see Appendix C.
 3.9.3 The Complement command
The command Complement[listAll,list1,...,listn] gives a complement of the list <listAll> with respect to
the union of all other lists <list1,...,listn>. In other words, it returns all the elements of <listAll> which are
not in any of <listk>. Note that Complement sorts the resulting list. Examples:86
Complement@8a, b, c, d, e, f<, 8b, c, e<D
8a, d, f<
Complement@8a, b, c, d, e, f<, 8b, c, e<, 8d, e, f<D
8a<
Complement@8a, b, c, d, e, f<, 8b, c, e<, 8d, e, f<, 8a, b, c<D
8<
The Complement command, like Intersection, has the option SameTest, which allows us to define our
own notion of "sameness" of objects. All the comments I made for Intersection with this option, also apply
here.
3.10
Functions related to list sorting
Here we will discuss three very useful built-in functions related to list sorting. Sort function sorts the list.
Union function removes duplicate elements from the list and also sorts the result. Split function splits the
list into sublists of same adjacent elements. For all three functions, one can define the notion of
"sameness" different from the default one. Below we give more details and examples of use for every of
these functions.
 3.10.1 The Sort command
 3.10.1.1
Basic Sort
This function is used for list sorting. For example :
Clear@a, b, c, d, e, f, g, tD;
Sort@8a, d, e, b, g, t, f, d, a, b, f, c<D
8a, a, b, b, c, d, d, e, f, f, g, t<
Sort@85, 7, 2, 4, 3, 1<D
81, 2, 3, 4, 5, 7<
Sort will sort a list of arbitrary Mathematica expressions. By default, the sorting is performed lexicographi-
cally for symbols, in ascending order for numbers, by the first elements for lists. In general, this is called a
canonical sorting order in Mathematica - consult Mathematica Help for more information.
For example, here we will sort a nested list of integers:
nested =
Table@Random@Integer, 81, 15<D, 85<, 8Random@Integer, 83, 10<D<D
8813, 3, 11, 7<, 815, 15, 14, 11, 15, 14<,
811, 10, 2<, 811, 12, 9, 11, 1, 4<, 87, 4, 15, 11, 9<<87
Sort@nestedD
884, 13, 3<, 811, 1, 9, 10, 7<, 813, 6, 15, 10, 12, 7<,
815, 8, 9, 1, 6, 2<, 813, 10, 9, 4, 7, 3, 15, 14, 8<<
We see that the sorting is performed by the first element of the sublists.
 3.10.1.2
Sort with a user-defined sorting function
As an optional second argument, Sort accepts the comparison function to be used instead of the default
one. For example:
Sort@85, 7, 2, 4, 3, 1<, GreaterD
87, 5, 4, 3, 2, 1<
We can for instance sort our nested list by the length of a sublist. We first define a sorting function:
Clear@sortFunctionD;
sortFunction@x_List, y_ListD := Length@xD < Length@yD;
And now sort:
Sort@nested, sortFunctionD
884, 13, 3<, 811, 1, 9, 10, 7<, 813, 6, 15, 10, 12, 7<,
815, 8, 9, 1, 6, 2<, 813, 10, 9, 4, 7, 3, 15, 14, 8<<
 3.10.1.3 A first look at pure functions
Mathematica provides a mechanism to construct and use functions without giving them names or sepa-
rate definitions, the so called "pure functions" (they are called lambda functions in some other languages).
We will cover them systematically later, but this is how the previous sorting would look should we use a
pure function:
Sort@nested, Length@ð1D < Length@ð2D &D
884, 13, 3<, 811, 1, 9, 10, 7<, 813, 6, 15, 10, 12, 7<,
815, 8, 9, 1, 6, 2<, 813, 10, 9, 4, 7, 3, 15, 14, 8<<
Any function of two variables which always returns True or False, can be a sorting function. It is assumed
that it gives True or False depending on which element is considered "larger".
I have to mention also that using Sort with a user - defined sorting function may considerably slow down
the Sort function. For a more detailed discussion, please see Appendix C.
 3.10.1.4
The Ordering command
This command gives a permutation of indices needed to sort an input list. It also exists in both "pure" form
and with a user - defined comparison function. It gives more information than just Sort, but in particular
one can also sort a list using a combination of Ordering and Part.88
For example, here is a list we considered before :
listtosort = 8a, d, e, b, g, t, f, d, a, b, f, c<
8a, d, e, b, g, t, f, d, a, b, f, c<
Ordering@listtosortD
81, 9, 4, 10, 12, 2, 8, 3, 7, 11, 5, 6<
listtosort@@Ordering@listtosortDDD
8a, a, b, b, c, d, d, e, f, f, g, t<
Ordering is a very useful command, exactly because it provides more information than just Sort, while
being as efficient as Sort itself. We will see an example of its use in chapter VI.
 3.10.2 The Union command
The command Union[list] returns a canonically sorted list of all distinct elements of < list > .
 3.10.2.1
Basic Union
In its basic form, Union takes a list as a single argument, and returns sorted unique elements in a list. The
sorting is done by a default sorting function in Mathematica (this is lexicographic for symbolic expres-
sions, in increasing order for numeric ones, by first element for lists etc). Examples :
Union@8a, d, e, b, g, t, f, d, a, b, f, c<D
8a, b, c, d, e, f, g, t<
testlist = Table@Random@Integer, 81, 10<D, 815<D
89, 7, 4, 3, 1, 1, 8, 2, 2, 10, 7, 4, 9, 1, 4<
Union@testlistD
81, 2, 3, 4, 7, 8, 9, 10<
The fact that the Union command sorts the resulting list, is intrinsically related with the algorithm that
Union uses. If the elements should not be sorted, one can write a custom union function (we will consider
a couple of implementations later, see section 5.2.6.2.5), which however will certainly be slower than the
built-in Union.
 3.10.2.2 Union with the SameTest option
The Union command has an option SameTest, which allows us to give it our own definition of which
elements have to be considered same. For example, we may consider elements the same if they are the
same modulo 3:
Union@testlist, SameTest ® HMod@ð1 -ð2, 3D  0 &LD
81, 2, 3<
It should be noted that Union with the SameTest function may perform slower or much slower than the
"pure" Union. For more details and discussion, please see the Appendix C.89
It should be noted that Union with the SameTest function may perform slower or much slower than the
"pure" Union. For more details and discussion, please see the Appendix C.
 3.10.3
The Split command
This command is used to split the list into several sublists, so that elements in each sublist are the same.
This function can accept the "sameness" function as an optional second argument. It goes through the list
and compares adjacent elements, using either the default sameness function, which is SameQ, or the
sameness function provided to it. Whenever two adjacent elements are not the same, it groups the just
passed group of same elements in a sublist and starts a new sublist.
 3.10.3.1
Basic Split
In its basic form, Split takes a list to split, as a single argument, and uses the SameQ predicate for element
comparison. For example, here we introduce a list and its sorted version:
testlist = Table@Random@Integer, 81, 15<D, 820<D
sorted = Sort@testlistD
88, 12, 10, 3, 13, 15, 13, 6, 6, 2, 4, 9, 5, 11, 6, 10, 7, 4, 15, 5<
82, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 9, 10, 10, 11, 12, 13, 13, 15, 15<
Because in general the adjacent elements in an unsorted list are different, we see that most sublists here
will contain a single element:
Split@testlistD
888<, 812<, 810<, 83<, 813<, 815<, 813<, 86, 6<,
82<, 84<, 89<, 85<, 811<, 86<, 810<, 87<, 84<, 815<, 85<<
Not so for a sorted list:
Split@sortedD
882<, 83<, 84, 4<, 85, 5<, 86, 6, 6<, 87<,
88<, 89<, 810, 10<, 811<, 812<, 813, 13<, 815, 15<<
 3.10.3.2
Split with a user-defined sameness function
We can now define two elements the same if, for example, they have the same remainder under the divi-
sion by 3. However, before using Split to group such elements together, we will have to sort the list with a
different sorting function, so that elements which are the same modulo 3 will be adjacent to each other in a
sorted list:
mod3sorted = Sort@testlist, Mod@ð1, 3D < Mod@ð2, 3D &D
815, 6, 9, 6, 6, 15, 3, 12, 4, 7, 10, 4, 13, 13, 10, 5, 11, 5, 2, 8<
Now we can split this list:
Split@mod3sorted, Mod@ð1, 3D  Mod@ð2, 3D &D
8815, 6, 9, 6, 6, 15, 3, 12<, 84, 7, 10, 4, 13, 13, 10<, 85, 11, 5, 2, 8<<
Split is a very useful function. Since it performs a single run through the list and only compares adjacent
elements, its complexity is linear. Also, because the number of comparisons is equal to the length of the
list (minus one), it does not suffer so severely from the performance penalties associated with the use of
user-defined sameness functions, which we discussed for the Sort and Union functions.90
Split is a very useful function. Since it performs a single run through the list and only compares adjacent
elements, its complexity is linear. Also, because the number of comparisons is equal to the length of the
list (minus one), it does not suffer so severely from the performance penalties associated with the use of
user-defined sameness functions, which we discussed for the Sort and Union functions.
 3.10.3.3
Example: run-length encoding
One standard application of Split is a run-length encoding. Given a list of possibly repetitive numbers, this
encoding consists of replacing this list with a list of elements like {{num1,freq1},...}, where <freqk> gives
the total number of consecutive copies of <numk>. For instance, take the result of our first example: all
we need to do is to change each sublist to the form just described, which can be done for example like this:
Clear@runEncodeSplitD;
runEncodeSplit@spl_ListD :=
Table@8spl@@i, 1DD, Length@spl@@iDDD<, 8i, Length@splD<D;
Clear@runEncodeD;
runEncode@x_ListD := runEncodeSplit@Split@xDD;
Check:
runEncode@sortedD
882, 1<, 83, 2<, 84, 3<, 85, 1<, 86, 2<,
88, 2<, 89, 1<, 811, 4<, 812, 2<, 814, 1<, 815, 1<<
With the functional programming, we can eliminate the need of an auxiliary function runEncodeSplit:
Clear@runEncodeFPD;
runEncodeFP@x_ListD := Map@8First@ðD, Length@ðD< &, Split@xDD;
Check:
runEncodeFP@testlistD
881, 1<, 82, 3<, 83, 1<, 84, 2<,
88, 3<, 89, 3<, 810, 4<, 813, 1<, 815, 2<<
 3.10.3.4
Example: computing frequencies of identical list elements
As another related application of Split, we will use it in conjunction with Sort to implement a function
which will count frequencies of the identical elements in a list. This is extremely easy to do if we notice
that we just have to Sort the original list and the use the <runEncode> function on a sorted list:
Clear@frequenciesD;
frequencies@x_ListD := runEncode@Sort@xDD;
Check:
frequencies@testlistD
882, 1<, 83, 2<, 84, 3<, 85, 1<, 86, 2<,
88, 2<, 89, 1<, 811, 4<, 812, 2<, 814, 1<, 815, 1<<
In fact, in essentially the same way the function Frequencies is implemented in the ‘Statistics‘DataManip-
ulation add-on package.91
In fact, in essentially the same way the function Frequencies is implemented in the ‘Statistics‘DataManip-
ulation add-on package.
There are many other situations where Split is quite useful - we will give further examples of its use in the
subsequent chapters.
Clear@testlist, sorted, mod3sorted, listDivide,
frequencies, runEncodeSplit, runEncode, runEncodeFPD;
Summary
In this chapter we introduced lists - the main building blocks of data structures in Mathematica. We
considered various operations on lists such as list generation, element extraction, addition, replacement
and deletion, locating elements with certain properties in the list, and also several specialized commands
for fast structural operations on one or several lists, as well as those related to sorting of lists. The follow-
ing built-in functions were considered in detail: Range,Table,Part, Extract, Take, Drop, First, Rest, Most,
Last, Position, Length, Append, Prepend, AppendTo, PrependTo, Partition, Transpose, Flatten, Join,
Union, Intersection, Complement, Sort, Split.
Armed with these functions, we can already go a long way in solving various problems. However, we
need another major component for serious program building - an understanding of functions in Mathemat-
ica: what they are, how to define them, etc. This is a topic of the next chapter.
